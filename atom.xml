<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cyukang.com/"/>
  <updated>2018-02-13T02:03:26.086Z</updated>
  <id>http://cyukang.com/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ruby的 open 函数导致命令执行</title>
    <link href="http://cyukang.com/2018/02/12/ruby-open-vul.html"/>
    <id>http://cyukang.com/2018/02/12/ruby-open-vul.html</id>
    <published>2018-02-12T12:39:46.000Z</published>
    <updated>2018-02-13T02:03:26.086Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>首先看看 open 函数的文档说明， <a href="https://apidock.com/ruby/v1_9_3_392/Kernel/open/class：" target="_blank" rel="external">https://apidock.com/ruby/v1_9_3_392/Kernel/open/class：</a> </p>
<blockquote>
<p>If <em>path</em> starts with a pipe character, a subprocess is created, connected to the <a href="https://apidock.com/ruby/Kernel/caller" target="_blank" rel="external">caller</a> by a pair of pipes. The returned <a href="https://apidock.com/ruby/IO" target="_blank" rel="external">IO</a> object may be used to write to the standard input and read from the standard output of this subprocess. If the command following the “|” is a single minus sign, Ruby forks, and this subprocess is connected to the parent. In the subprocess, the <a href="https://apidock.com/ruby/Kernel/open" target="_blank" rel="external">open</a> call returns nil. If the command is not “-”, the subprocess runs the command. If a block is associated with an <a href="https://apidock.com/ruby/Kernel/open" target="_blank" rel="external">open</a>(“|-”) call, that block will be run twice—once in the parent and once in the child. The block parameter will be an <a href="https://apidock.com/ruby/IO" target="_blank" rel="external">IO</a> object in the parent and nil in the child. The parent’s <a href="https://apidock.com/ruby/IO" target="_blank" rel="external">IO</a> object will be connected to the child’s stdin  and stdout. The subprocess will be terminated at the end of the block.</p>
</blockquote>
<p>其中说明了如果以|开头则会 fork 出一个进程，<code>|</code> 后面的内容则会当成一条命令执行，比如： </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">cmd = open(<span class="string">"|date"</span>)</div><div class="line">print cmd.gets</div><div class="line">cmd.close</div><div class="line">=&gt; <span class="number">2018</span>年 <span class="number">2</span>月<span class="number">12</span>日 星期一 <span class="number">21</span>时<span class="number">37</span>分<span class="number">45</span>秒 CST</div></pre></td></tr></table></figure>
<h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>正因为这样，这个 open 函数真的是很容易出错，最近的这个 PR： </p>
<p><a href="https://github.com/ruby/ruby/pull/1777" target="_blank" rel="external">https://github.com/ruby/ruby/pull/1777</a></p>
<p>之前我们的项目里也出现过类似的情况，直接相当于一个 webshell，任意执行命令。这样的 command injection 当然也很好检测，brakeman 之类的就可以。所以 Rails项目还是时不时地扫描一下比较好。</p>
<p>Ruby 里面有几个 Open，<a href="https://stackoverflow.com/questions/1727217/file-open-open-and-io-foreach-in-ruby-what-is-the-difference" target="_blank" rel="external">这里</a>有比较明晰的解释，Kernel.open 这个函数就是一个 wrapper，根据不同的情况做对应的处理。趟多了坑之后，才会觉得这样的特性其实是增加了程序员的负担，比如这个<code>|</code>特性可能有的人就没注意到，即使是看过文档也可能看到了<a href="https://apidock.com/ruby/v1_8_6_287/Kernel/open" target="_blank" rel="external">老版本的文档</a>，从而不知道这个边边角角。</p>
<p>当然同样的 system这样的命令执行函数也是类似的情况，比如<a href="https://github.com/OWASP/railsgoat/wiki/A1-Command-Injection" target="_blank" rel="external">railsgoat 里的这个 command injection</a>。原则是对于任何用户输入的参数，都需要做不安全的假设，做好检查。</p>
<p><a href="https://github.com/OWASP/railsgoat" target="_blank" rel="external">https://github.com/OWASP/railsgoat</a>这个项目里有各种 Rails漏洞，值得看看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;首先看看 open 函数的文档说明， &lt;a href=&quot;https://apidock.com/ruby/v1_9_3_392/Kernel
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BuckleScript and Reason</title>
    <link href="http://cyukang.com/2017/09/17/bucklescript-and-reason.html"/>
    <id>http://cyukang.com/2017/09/17/bucklescript-and-reason.html</id>
    <published>2017-09-17T14:47:27.000Z</published>
    <updated>2017-09-18T04:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="BuckleScript"><a href="#BuckleScript" class="headerlink" title="BuckleScript"></a>BuckleScript</h4><p>虽然我不是前端工程师，不过因为喜欢 OCaml，所以偶尔关注 <a href="https://github.com/BuckleScript/bucklescript" target="_blank" rel="external">BuckleScript</a> 有一段时间了，今天又花时间看了看文档和代码。BuckleScript 是张宏波主导开发的开源项目，『有希望成为第一个完全由国人设计主导实现并被世界各地广泛使用的编译器』，不过是否能广泛被使用还得看后续推广。</p>
<p>简单来说BuckleScript 是一个代码转换器，把你写的 OCaml 代码生成为纯 JS 代码。这样做的好处和必要性在于：</p>
<ol>
<li>JS 太牛了，<a href="https://www.youtube.com/watch?v=jFU-wc28lF4" target="_blank" rel="external">这个跨平台语言正在吞噬着所有软件领域</a></li>
<li>JS太难维护了，大规模的 JS 代码更是噩梦。不管是从开发者角度和是从代码安全的角度，JS 需要类型！<a href="https://www.typescriptlang.org/" target="_blank" rel="external">微软的 Typescript</a> 和 <a href="https://flow.org/en/" target="_blank" rel="external">FB 的 Flow</a> ，甚至是<a href="http://elm-lang.org/examples" target="_blank" rel="external">Elm</a>都是为了给 JS 带来类型。</li>
<li>OCaml类型系统稳定可靠，关键是编译器速度快，并且可以编译在多个平台上。</li>
</ol>
<p>就我个人而言非常喜欢 OCaml，之前也有一些自己的小项目用过 OCaml。BuckleScript从技术角度来说是非常好的，我看了一些生成的代码可读性比很多代码生成器要好。并且除了直接翻译代码，这个编译器也做了很多代码优化的工作，生成 size 更小，performance 更好的 JS 代码。遗憾的是目前还不支持 Core 这个库，我之前用 Core 比较多，ಥ_ಥ。</p>
<p>关于代码生成，想起我们原来做过的 <a href="https://github.com/sipin/gorazor" target="_blank" rel="external">Gorazor</a>，从技术角度来说还是有些挑战的，不过从使用角度我个人持保留态度。代码生成毕竟会引入新的语法，我发现很多前端程序员其实并不怎么熟悉函数式编程那套，OCaml 的语法是否能在前端程序员中推广开来是个问题。BuckleScript的文档有待改进，可以给更多大一点的完整的例子。</p>
<p>关于BuckleScript和js_of_ocaml 的区别，从文档上来看js_of_ocaml 可以把 bytecode 转换为 JS 代码，而BuckleScript是在从编译器里面的rawlambda生成代码，所以理论上来说 js_of_ocaml 对 OCaml 的兼容性更好，而BuckleScript 能生成更可读的 JS 代码，目标在于兼容npm平台。</p>
<h4 id="ReasonML"><a href="#ReasonML" class="headerlink" title="ReasonML"></a>ReasonML</h4><p><a href="https://reasonml.github.io/" target="_blank" rel="external">ReasonML</a>的来由是之前我说的 OCaml 独特的语法，在很多人看来并不是很友好，所以FB 的这群人做了一个更符合大众品位的方言。然后可以通过 BuckleScript 再翻译为 JS 代码。好绕啊！不过据说 FB 已经在生成环境使用这些了。ReasonML 的开发者移植了一个之前用js_of_ocaml 写的<a href="https://github.com/reasonml-community/Mareo" target="_blank" rel="external">mario 的例子</a>，看了一遍觉得reason 的语法其实改动并不大，可能对 JS 的程序员来说更友好吧。reason 和 OCaml 的关系类似于 Elixir 和 Erlang 之前的关系，为了讨好一类程序员，又为了利用一个已经非常成熟可靠的现有平台。</p>
<p>在 HN 上有一个比较老的<a href="https://news.ycombinator.com/item?id=12400397" target="_blank" rel="external">讨论帖</a>，有时间也可以再看看。</p>
<p><a href="https://github.com/BuckleScript/bucklescript/wiki/Why-bucklescript-matters-for-Javascript-platform" target="_blank" rel="external">Why bucklescript matters for Javascript platform</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;BuckleScript&quot;&gt;&lt;a href=&quot;#BuckleScript&quot; class=&quot;headerlink&quot; title=&quot;BuckleScript&quot;&gt;&lt;/a&gt;BuckleScript&lt;/h4&gt;&lt;p&gt;虽然我不是前端工程师，不过因为喜欢 OCaml，所以偶尔关注
    
    </summary>
    
    
      <category term="OCaml" scheme="http://cyukang.com/tags/OCaml/"/>
    
      <category term="Javascript" scheme="http://cyukang.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>《深度工作-如何有效使用每一点脑力》读后</title>
    <link href="http://cyukang.com/2017/09/14/deep-work.html"/>
    <id>http://cyukang.com/2017/09/14/deep-work.html</id>
    <published>2017-09-14T14:20:14.000Z</published>
    <updated>2017-09-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/27056409/" target="_blank" rel="external">深度工作</a>这本书主要讲解了一些时间和精力管理方面的东西，人到了一定年龄就会觉得时间不够用，日子过得太快，每天觉得都没干什么就过去了。工作几年后这种感觉时不时袭来。反而是如果某段时间一直有一个阶段性的目标，就会觉得很踏实，进度和效率也可以。那种完全沉浸在思考中的状态真的也并不是累，相反所得到的结果往往是真实的收获和进步。用这本书里的术语可以称之为『深度工作』的阶段吧。</p>
<p>说起来也有道理，如果自认为我们是知识工作者，那么大多数时间处于浮潜的工作状态就得不到什么深刻的结果。作为程序员，我也有时候感觉自己并不是在做什么高深的工作，那么这样长久下去会怎么样呢，随之而来的是不可避免的压力。</p>
<p>这里讲的四个准则，任何一个都值得好好修炼，对于大多数人而言，大脑都已经被互联网和手机训练得愚钝和不可专注了：</p>
<blockquote>
<p>工作要深入<br>拥抱无聊<br>远离社交媒体<br>摒弃浮浅</p>
</blockquote>
<p>深入工作的价值在当今社会格外突出，因为机器的迅猛发展，特殊的技能所展现的价值越发明显。『连续听一系列中等水平的歌手唱歌并不能累加成一场无与伦比的演出— 换言之，才能并非一种商品，你不可以通过大批购买，然后累积起来达到一定水准，只有成为最优秀的才会得到额外奖励』。我们所面临的时代需要掌握一些更为复杂的工作和技能，而这些技能并不是随便看看就能轻易得到的。深入的东西只有静下心来，持续花大量时间和精力才能逐渐掌握。</p>
<p>想要进入深度工作，会有两个方面需要注意:</p>
<ol>
<li>时间分配，如何避免被频繁打断，如何尽量延长一大段可以持续的时间</li>
<li>学习和锻炼持续专注的能力</li>
</ol>
<p>关于时间分配，我之前尝试过番茄工作法，但是感觉并不好。因为仪式感太强和太频繁，在我正在进入工作状态的时候可能就到了节点。对于大多数程序员来说晚上可能是最能安静的写程序和思考的时间，不过随着更多的家庭责任，晚上的时间也短了。所以现在我打算早上尽早起来，这样还有一两个小时加以利用。</p>
<p>关于专注能力这块：</p>
<blockquote>
<p>不断地切换注意力会对大脑产生长久的负面影响</p>
</blockquote>
<p>这个结论应该大家都有体会，持续专注的能力往往决定人的能力，有的人可以一直脑袋里想着问题，即使是在走路或者吃饭的时候。之前在学校我也有过一段时间，脑袋里一直在想着要找的答案，那种体验已经好久没有了。</p>
<p>总之，这本书还不错，推荐有时间的话看看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/27056409/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深度工作&lt;/a&gt;这本书主要讲解了一些时间和精力管理方面的东西，人到了一定年龄就会觉得时间不够用，日子过得太快
    
    </summary>
    
    
      <category term="Books" scheme="http://cyukang.com/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>Kong的0.11.0版本</title>
    <link href="http://cyukang.com/2017/09/12/kong-new-release.html"/>
    <id>http://cyukang.com/2017/09/12/kong-new-release.html</id>
    <published>2017-09-12T06:43:00.000Z</published>
    <updated>2017-09-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kong发布了新的版本<a href="https://github.com/Mashape/kong/releases/tag/0.11.0" target="_blank" rel="external">0.11.0</a>，从这里开始区分了社区版本和商业版。这次改动比较大的是丢弃了serf，这样整个Kong节点之间的缓存同步方式变化了。开发者给出的理由如下： </p>
<ol>
<li>依赖serf，serf并不属于Nginx/OpenResty</li>
<li>这种依赖相互间通信来同步的机制对于deployment和容器化都有些不便</li>
<li>在运行的Kong节点触发serf需要一些租塞的I/O</li>
</ol>
<p>新的实现的思路是以数据库作为中心，增加一个cluster events的表。任何Kong node都可以向数据库发送变更消息，其他节点polling数据库改动，然后来更新缓存内容。这个改动非常大，不过最终Kong终于实现了节点无状态，之前那个数据库里的nodes可以丢弃掉了，任何时候节点重启只要连上数据库即可工作。我们需要担心的是这么多节点去polling数据库(当然这些动作都是在后台)，是否是一个比较耗时的工作。</p>
<p>Kong增加了新的配置选项db_update_frequency，默认为5s，表示多长时间polling一次，这需要用户自己权衡效率和及时性了。对于我们的业务来说及时性还是很重要的，比如我们新品发布时间精确到秒，那么我们就需要尽量调低这个参数。</p>
<p>所有的改动在<a href="https://github.com/Mashape/kong/pull/2561/files，" target="_blank" rel="external">https://github.com/Mashape/kong/pull/2561/files，</a></p>
<p>我大概看了一下代码，一些值得注意的地方如下：</p>
<ol>
<li>cluster相关的API和cmd都被移掉了，启动部分和serf信号处理部分都删掉了不少代码。</li>
<li>polling需要避免一个问题，比如上一次polling还未执行完成，下一次polling就不应该启动，所以这里需要锁来处理。<a href="https://github.com/Mashape/kong/pull/2561/files#diff-44982f7ff5cb89eaf66ed31217aa0d12" target="_blank" rel="external">kong/cluster_events.lua</a>实现了polling的主要过程。</li>
<li><a href="https://github.com/Mashape/kong/pull/2561/files#diff-904358fb4394ddf0541b4b3ede669a82" target="_blank" rel="external">kong/cluster_events/strategies/postgres.lua</a>目前polling还不支持分页，cluster_events是一个新建的表用来存储缓存更新事件，Kong节点就是来查询这些事件。</li>
<li>缓存部分换成了<a href="https://github.com/thibaultcha/lua-resty-mlcache" target="_blank" rel="external">lua-resty-mlcache</a>，原来还是和之前分析的类似 L1级别缓存为一个LURcache，在LuaVM里可见， L2级别的缓存为lua_shared_dict，同一个Nginx下的所有worker可见， L3就是缓存未命中的情况，需要调用其他hookup的函数去获取数据然后缓存在L2。只是这里个ipc并不是用的lua-resty-mlcache里的，而是使用的resty.worker.events。</li>
<li>事件处理部分分两部分，worker之间的事件和node之间的处理，分别由worker_events和cluster_event.lua来处理。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kong发布了新的版本&lt;a href=&quot;https://github.com/Mashape/kong/releases/tag/0.11.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;0.11.0&lt;/a&gt;，从这里开始区分了社区版本和商业版。这次改动比
    
    </summary>
    
    
      <category term="Lua" scheme="http://cyukang.com/tags/Lua/"/>
    
      <category term="Kong" scheme="http://cyukang.com/tags/Kong/"/>
    
  </entry>
  
  <entry>
    <title>Lua时间处理</title>
    <link href="http://cyukang.com/2017/09/12/lua-time-related.html"/>
    <id>http://cyukang.com/2017/09/12/lua-time-related.html</id>
    <published>2017-09-12T01:51:00.000Z</published>
    <updated>2017-09-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我需要用Lua处理一个与时间相关的问题，比如我们在配置文件里面配置一个日期(北京时间)，然后在Openresty里面判断当前时间是否在这个日期之前或者之后来做对应的逻辑。</p>
<p>Lua的时间处理还有点麻烦，主要是自带的相关库函数比较少。</p>
<blockquote>
<p>os.time()                &lt;== 返回当前系统的日历时间， 1505181586<br>os.date()                &lt;== 返回本地化的时间字符串，Tue Sep 12 09:59:56 2017<br>os.clock()               &lt;== 返回执行该程序CPU花去的时钟秒数，这里是1156.726</p>
</blockquote>
<p>我首先需要一个日期字符串转换为时间戳的函数，找来找去有了这么一个函数，使用正则表达式然后组成表：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert_time</span><span class="params">(time_str)</span></span></div><div class="line">  <span class="comment">-- Assuming a date pattern like: yyyy-mm-dd hh:mm:ss</span></div><div class="line">  <span class="comment">-- Assuming timezone is Beijing</span></div><div class="line">  <span class="keyword">local</span> pattern = <span class="string">"(%d+)-(%d+)-(%d+) (%d+):(%d+):(%d+)"</span></div><div class="line">  <span class="keyword">local</span> year, month, day, hour, minute, seconds = time_str:<span class="built_in">match</span>(pattern)</div><div class="line">  <span class="keyword">if</span> <span class="keyword">not</span> (year <span class="keyword">and</span> month <span class="keyword">and</span> day <span class="keyword">and</span> hour <span class="keyword">and</span> minute <span class="keyword">and</span> seconds) <span class="keyword">then</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="keyword">local</span> converted_timestamp =</div><div class="line">    <span class="built_in">os</span>.<span class="built_in">time</span>(&#123;tz = <span class="string">"CST"</span>, year = year, month = month,</div><div class="line">             day = day, hour = hour, <span class="built_in">min</span> = minute, sec = seconds&#125;)</div><div class="line">      </div><div class="line">    <span class="keyword">return</span> converted_timestamp </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>然后我们可以使用os.time()获取当前时间戳来对比。但是必须注意时区问题，Lua里面要获取当前时区和UTC里面的offset可以使用一个比较笨拙的办法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_timezone_offset_with_utc</span><span class="params">()</span></span></div><div class="line">  <span class="keyword">local</span> now = <span class="built_in">os</span>.<span class="built_in">time</span>()</div><div class="line">  <span class="keyword">return</span> <span class="built_in">os</span>.<span class="built_in">difftime</span>(now, <span class="built_in">os</span>.<span class="built_in">time</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"!*t"</span>, now)))</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>使用这个函数获取时区的offset之后，对convert_time返回的结果做一下偏移即可和os.time()做对比。有个问题是上面的函数居然调用了三次系统调用，开销是比较大的。</p>
<blockquote>
<p>在 OpenResty 的世界里，不推荐使用这里的标准时间函数，因为这些函数通常会引发不止一个昂贵的系统调用，同时无法为 LuaJIT JIT 编译，对性能造成较大影响。推荐使用 ngx_lua 模块提供的带缓存的时间接口，如 <code>ngx.today</code>, <code>ngx.time</code>, <code>ngx.utctime</code>, <code>ngx.localtime</code>, <code>ngx.now</code>, <code>ngx.http_time</code>，以及 <code>ngx.cookie_time</code> 等。</p>
</blockquote>
<p><a href="https://github.com/stevedonovan/Penlight/blob/master/lua/pl/Date.lua" target="_blank" rel="external">Penlight</a>库也有很多日期相关的函数封装，不过大多也都使用了os相关函数。为了避免多次调用get_timezone_offset_with_utc我使用了Kong里面自带的cache相关函数做一下缓存：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- 缓存上面的时区差，减少系统调用</span></div><div class="line"><span class="keyword">local</span> offset_with_cst, err =</div><div class="line">  cache.get_or_set(<span class="string">"timezone_offset"</span>, <span class="literal">nil</span>, get_timezone_offset_with_utc, <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我需要用Lua处理一个与时间相关的问题，比如我们在配置文件里面配置一个日期(北京时间)，然后在Openresty里面判断当前时间是否在这个日期之前或者之后来做对应的逻辑。&lt;/p&gt;
&lt;p&gt;Lua的时间处理还有点麻烦，主要是自带的相关库函数比较少。&lt;/p&gt;
&lt;blockquot
    
    </summary>
    
    
      <category term="Lua" scheme="http://cyukang.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>使用 exercism 来练手学语言</title>
    <link href="http://cyukang.com/2017/08/22/pl-practice-with-exercism.html"/>
    <id>http://cyukang.com/2017/08/22/pl-practice-with-exercism.html</id>
    <published>2017-08-22T04:12:02.000Z</published>
    <updated>2017-08-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们想学一门编程语言，但是光看看书和代码用例总是找不到感觉，这时候我们应该尝试写点不短不长的程序片段，可能是一个函数，或者是实现一个简单的算法。最近我发现这个叫做<a href="http://exercism.io/" target="_blank" rel="external">exercism.io</a>的网站不错，自己也在闲余时间在上面看看。</p>
<p>这里支持30多种编程语言，每种语言大概有80个左右的小问题，每个题目已经写好了对应的测试用例。这些题目不是专门的算法题目，但会涉及到编程语言相关的基本方面，单元测试、字符串，数字处理，代码风格等。我们可以随机的找一些来练练手，提交自己的代码后也可以看看别人的代码。然后再对自己的代码进行一些改进。其他人也可能会对我提交的代码 review 并提交改进评论。多写和多看确实就是学习编程的最好途径。</p>
<p><a href="http://exercism.io/" target="_blank" rel="external">http://exercism.io/</a>当然是开源的，大家都可以提供题目和测试。具体使用起来可以参考<a href="http://exercism.io/how-it-works/newbie" target="_blank" rel="external">文档</a>，其中有已经实现好的 cli 工具，每做一个 fetch 一下即可看到下一题。如果你对数学或者算法方面的问题更感兴趣，也可以试试<a href="https://projecteuler.net/" target="_blank" rel="external">https://projecteuler.net/</a>，这个则不限语言，只需要最终结果即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们想学一门编程语言，但是光看看书和代码用例总是找不到感觉，这时候我们应该尝试写点不短不长的程序片段，可能是一个函数，或者是实现一个简单的算法。最近我发现这个叫做&lt;a href=&quot;http://exercism.io/&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
    
      <category term="PL" scheme="http://cyukang.com/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>从 Jekyll换成Hexo</title>
    <link href="http://cyukang.com/2017/08/12/migrate-to-hexo.html"/>
    <id>http://cyukang.com/2017/08/12/migrate-to-hexo.html</id>
    <published>2017-08-12T00:38:00.000Z</published>
    <updated>2017-08-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天看到自己的 Blog 在移动端显示丑死了，所以想着优化一下，找一个 mobile first 的风格试试。顺便把 blog 从 jekyll 换成了 Hexo。最后找到这个 <a href="https://github.com/yanm1ng/hexo-theme-vexo" target="_blank" rel="external">hexo 的主题</a>非常顺眼，便拿来用了，感谢<a href="https://github.com/yanm1ng" target="_blank" rel="external">yanm1ng</a>为大家提供如此优秀的主题。回想起自己之前用过搜狐博客，然后是 yo2，然后是 wordpress 自己搭，后来又出现了 jekyll，最终才找到最适合的写日志的方式。这次我把之前残留的 html 完全转换为了 markdown，并保留了创建日期，没想到这么多年来断断续续已经写了100来篇文章了。</p>
<h4 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h4><p>hexo 其实和 jekyll 非常类似，只是迁徙过程中还是需要做一些处理。hexo 的文章排序选择了 date 倒序排，但是依赖于_post 里的文件创建时间，为了解决这个问题，然而 git 是不管理文件的时间戳的。结果会出现一些诡异的问题，文章的顺序会变乱。后来才发现 hexo 为了解决这个问题引入了一个叫做 db.json 的文件，存的内容大概是文件的时间戳之类的。为了保持之前的文章链接有效，写了一些小脚本处理文章。</p>
<h4 id="gitment"><a href="#gitment" class="headerlink" title="gitment"></a>gitment</h4><p>关于评论还发现一个很好的解决方案，那就是使用<a href="https://github.com/imsun/gitment" target="_blank" rel="external">gitment</a>，这个方案是专门针对 github 上 host 的博客系统的，唯一不爽的地方在于需要自己为新增文章初始化创建一个 issue，每一条评论会增加对应文章 issue 的comments。当然结果也导致了只有 github 帐号才能评论。不过我觉得这还是挺不错，毕竟 github 作为程序员的社交系统已经如此流行。</p>
<h4 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h4><p>另外经大家推荐尝试使用 markdown 编辑软件Typora。之前因为自己使用的 markdown 格式稍微有点差别， 而且也习惯了用 Emacs，所以并没用深度使用 Typora。这次好好尝试了一下，发现其可见即可得还是非常方便的。另外就是插入图片的时候可以直接拖入，并且配置一下图片的根目录，自动拷贝到图片目录(或者上传到图床)。这个功能真的很暖心，typora 的作者肯定也是用 git来管理自己的日志。</p>
<p><img src="/images/134871342111-2510476.jpg" alt="134871342111"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天看到自己的 Blog 在移动端显示丑死了，所以想着优化一下，找一个 mobile first 的风格试试。顺便把 blog 从 jekyll 换成了 Hexo。最后找到这个 &lt;a href=&quot;https://github.com/yanm1ng/hexo-theme-v
    
    </summary>
    
    
      <category term="Blog" scheme="http://cyukang.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Kong源码分析: 事件</title>
    <link href="http://cyukang.com/2017/07/23/kong-intro-5.html"/>
    <id>http://cyukang.com/2017/07/23/kong-intro-5.html</id>
    <published>2017-07-23T00:38:00.000Z</published>
    <updated>2017-07-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kong的缓存更新很多依赖于事件，而事件看起来是相对来说比较复杂、也是最有趣的一部分。</p>
<h3 id="worker模型"><a href="#worker模型" class="headerlink" title="worker模型"></a>worker模型</h3><p>假设我们对Kong做了一个更改的请求，这个请求通常是通过admin_api这个路由处理的。也就是说最终执行数据库操作的动作是在一个Nginx worker进程里。因为操作了数据库所以我们需要刷新这个Kong节点的所有worker的缓存，而且要把事件分发给其他Kong节点，让其他Kong节点刷新所有worker的缓存。</p>
<p><img src="/images/kong-message.png" alt="kong-message" class="img-center"></p>
<p>这就涉及到两部分:</p>
<ol>
<li>Kong节点之间的消息通信, 这是使用<a href="https://www.serf.io/" target="_blank" rel="external">serf</a>来实现的</li>
<li>Kong每个节点内部，也就是Nginx worker之间的通信，这是使用<a href="https://github.com/Mashape/lua-resty-worker-events" target="_blank" rel="external">lua-resty-worker-events</a>来进行。</li>
</ol>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>发布订阅是实现事件的一种经典设计模式，主要需要有两类操作：</p>
<ol>
<li>发布消息</li>
<li>订阅消息，收到消息后触发指定的函数。</li>
</ol>
<p>Kong使用的是一个<a href="https://github.com/Olivine-Labs/mediator_lua" target="_blank" rel="external">叫作mediator_lua</a>，mediator中文意思为”中间人”，很符合项目的意思。可以看到kong/core/events.lua里面实现如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Events:subscribe</span><span class="params">(event_name, fn)</span></span></div><div class="line">  <span class="keyword">if</span> fn <span class="keyword">then</span></div><div class="line">    self._mediator:subscribe(&#123;event_name&#125;, <span class="function"><span class="keyword">function</span><span class="params">(message_t)</span></span></div><div class="line">      fn(message_t)</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span> <span class="comment">-- Required to tell mediator to continue processing other events</span></div><div class="line">    <span class="keyword">end</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Events:publish</span><span class="params">(event_name, message_t)</span></span></div><div class="line">  <span class="keyword">if</span> event_name <span class="keyword">then</span></div><div class="line">    self._mediator:publish(&#123;<span class="built_in">string</span>.<span class="built_in">upper</span>(event_name)&#125;, message_t)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>Kong.init初始化的时候会调用一个叫做attach_hooks的函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">attach_hooks(events, require &quot;kong.core.hooks&quot;)</div></pre></td></tr></table></figure></p>
<p>在load插件的时候也会把插件对应hooks绑定上：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- Attaching hooks</span></div><div class="line"><span class="keyword">local</span> ok, hooks = utils.load_module_if_exists(<span class="string">"kong.plugins."</span> .. plugin .. <span class="string">".hooks"</span>)</div><div class="line"><span class="keyword">if</span> ok <span class="keyword">then</span></div><div class="line">  attach_hooks(events, hooks)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h3 id="事件的来源"><a href="#事件的来源" class="headerlink" title="事件的来源"></a>事件的来源</h3><p>上面说过，Kong节点之间通信是通过<a href="https://www.serf.io/" target="_blank" rel="external">serf</a>发送的。我们来看看事件是如何触发发出通知的。<br>事件来于源数据库的修改，那就应该在数据库代码部分有触发事件的代码，查看dao/dao.lua这个文件里的代码，我们可以看到在insert、update、insert执行的时候都调用了一行代码</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">event(self, event_types.ENTITY_DELETED, k, v.schema, entity)</div></pre></td></tr></table></figure>
<p>这个函数的实现如下，这里做了数据的序列化，然后发布了一种叫做CLUSTER_PROGATE类型的消息：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">event</span><span class="params">(self, type, table, schema, data_t)</span></span></div><div class="line">  <span class="keyword">if</span> self.events_handler <span class="keyword">then</span></div><div class="line">    .....  执行数据序列化</div><div class="line">    self.events_handler:publish(self.events_handler.TYPES.CLUSTER_PROPAGATE, payload)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在core/hooks.lua接受消息部分，events.TYPES.CLUSTER_PROPAGATE对应的处理部分是singletons.serf:event(message_t)，所以我们看serf.lua这个源文件，最终event调用了invoke_signal，这个函数会运行一个serf命令，类似于这样：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">serf event -coalesce=<span class="literal">false</span> -rpc-addr=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7373</span>  kong <span class="string">'&#123;"type":"ENTITY_UPDATED","primary_key":["id"],"collection":"apis","entity":&#123;"id":"94acca76-d61a-429e-86a9-5abf2c61ee31"&#125;&#125;'</span></div></pre></td></tr></table></figure>
<p>这就出发了一个serf event，其他Kong节点会收到此消息。</p>
<h3 id="serf-Kong节点之间通信"><a href="#serf-Kong节点之间通信" class="headerlink" title="serf: Kong节点之间通信"></a>serf: Kong节点之间通信</h3><p>那么Kong节点收到消息之后是如何处理的呢？Kong在启动的时候会在后台执行一个serf进程，类似这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">serf agent -profile wan -bind 0.0.0.0:7946 -log-level err -rpc-addr 127.0.0.1:7373 -event-handler member-join,member-leave,member-failed,member-update,member-reap,user:kong=/usr/local/kong/serf/serf_event.sh -node Kang.local_0.0.0.0:7946_be3b9352808e4839a272f30ca6025650</div></pre></td></tr></table></figure>
<p>可以看看serf_event.sh这个脚本，内容如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">PAYLOAD=`cat` # Read from <span class="built_in">stdin</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"$SERF_EVENT"</span> != <span class="string">"user"</span> ]; <span class="keyword">then</span></div><div class="line">  PAYLOAD=<span class="string">"&#123;\"type\":\"$&#123;SERF_EVENT&#125;\",\"entity\": \"$&#123;PAYLOAD&#125;\"&#125;"</span></div><div class="line">fi</div><div class="line"></div><div class="line">CMD=<span class="string">"\</span></div><div class="line"><span class="string">local http = require 'resty.http' \</span></div><div class="line"><span class="string">local client = http.new() \</span></div><div class="line"><span class="string">client:set_timeout(5000) \</span></div><div class="line"><span class="string">client:connect('127.0.0.1', 8001) \</span></div><div class="line"><span class="string">client:request &#123; \</span></div><div class="line"><span class="string">  method = 'POST', \</span></div><div class="line"><span class="string">  path = '/cluster/events/', \</span></div><div class="line"><span class="string">  body = [=[$&#123;PAYLOAD&#125;]=], \</span></div><div class="line"><span class="string">  headers = &#123; \</span></div><div class="line"><span class="string">    ['content-type'] = 'application/json' \</span></div><div class="line"><span class="string">  &#125; \</span></div><div class="line"><span class="string">&#125;"</span></div><div class="line"></div><div class="line">/usr/<span class="keyword">local</span>/openresty/bin/resty -e <span class="string">"$CMD"</span></div></pre></td></tr></table></figure>
<p>可以看到serf收到消息后会触发这个脚本，然后把消息发送到本节点的/cluster/events这个路由。api/routes/cluster.lua这个文件里有收到消息后的处理代码，其中最关键的是：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="comment">-- Trigger event in the node</span></div><div class="line">ev.post(constants.CACHE.CLUSTER, message_t.<span class="built_in">type</span>, message_t)</div></pre></td></tr></table></figure>
<p>就是通过resty.worker.events publish出收到的消息，本节点的worker会处理这些消息。</p>
<h3 id="worker刷新缓存"><a href="#worker刷新缓存" class="headerlink" title="worker刷新缓存"></a>worker刷新缓存</h3><p>假设当前Kong节点收到一个消息，这个消息是如何分发给各个worker的？从代码看出，在Kong初始化的时候有调用一个叫做kong.lua里面的Kong.init_worker()函数，其中有一段代码注册了event handler:<br><figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="keyword">local</span> worker_events = <span class="built_in">require</span> <span class="string">"resty.worker.events"</span></div><div class="line"></div><div class="line"><span class="keyword">local</span> handler = <span class="function"><span class="keyword">function</span><span class="params">(data, event, source, pid)</span></span>  </div><div class="line">  <span class="keyword">if</span> data <span class="keyword">and</span> data.collection == <span class="string">"apis"</span> <span class="keyword">then</span>    </div><div class="line">    <span class="built_in">assert</span>(core.build_router())</div><div class="line"></div><div class="line">  <span class="keyword">elseif</span> source <span class="keyword">and</span> source == constants.CACHE.CLUSTER <span class="keyword">then</span>    </div><div class="line">    singletons.events:publish(event, data)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">worker_events.register(handler)</div></pre></td></tr></table></figure></p>
<p>可以从上面的handler代码看到，一个worker接收到消息之后执行的是：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">singletons.events:publish(event, data)</div></pre></td></tr></table></figure>
<p>也就是通过mediator_lua再把消息publish。之前初始化的时候已经attach_hooks了各种handler，这时候那些注册的函数才会被最终执行，比如核心的刷新缓存部分代码在core/hooks.lua的invalidate函数里面。</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>总的来说Kong事件部分的代码相当精妙，也很统一。比如当前worker做了修改，这个事件会发送给各个节点，包括当前自己所在的节点。通过发布订阅模式，写代码的时候只需关心消息发送、接受消息索要处理的逻辑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kong的缓存更新很多依赖于事件，而事件看起来是相对来说比较复杂、也是最有趣的一部分。&lt;/p&gt;
&lt;h3 id=&quot;worker模型&quot;&gt;&lt;a href=&quot;#worker模型&quot; class=&quot;headerlink&quot; title=&quot;worker模型&quot;&gt;&lt;/a&gt;worker模型&lt;/h
    
    </summary>
    
    
      <category term="Lua" scheme="http://cyukang.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Kong源码分析: 缓存</title>
    <link href="http://cyukang.com/2017/07/22/kong-intro-4.html"/>
    <id>http://cyukang.com/2017/07/22/kong-intro-4.html</id>
    <published>2017-07-22T00:38:00.000Z</published>
    <updated>2017-07-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx里的缓存使用"><a href="#Nginx里的缓存使用" class="headerlink" title="Nginx里的缓存使用"></a>Nginx里的缓存使用</h3><p>在Kong里面我们缓存的内容大部分是配置，不管是API本身的配置还是插件相关的配置，缓存之后就存储在内存中。</p>
<p>Kong里的缓存基础代码在tools/database_cache.lua文件里面。这里又分两种类型的缓存，一种是<a href="https://github.com/openresty/lua-nginx-module#ngxshareddict" target="_blank" rel="external">shared dict</a>, 一种是使用<br><a href="https://github.com/openresty/lua-resty-lrucache" target="_blank" rel="external">lua-resty-lrucache</a>。这两者之间是有区别的: shared dict如同其名字一样是Nginx worker之间共享的，而lrucache是worker级别的，内存空间在Lua VM里由GC管理，不能在进程之间共享，自然也不会在Nginx worker之间共享。</p>
<p>具体我们开发中使用哪一种由具体场景分析，比如在Kong的插件rate-limiting里就使用了共享缓存，因为我们需要针对一个Nginx所有的worker做请求数统计。</p>
<p>share dict最常规的使用方法是:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">http &#123;</div><div class="line">    lua_shared_dict dogs <span class="number">10</span>m;</div><div class="line">    server &#123;</div><div class="line">        location /set &#123;</div><div class="line">            content_by_lua_block &#123;</div><div class="line">                <span class="keyword">local</span> dogs = ngx.shared.dogs</div><div class="line">                dogs:set(<span class="string">"Jim"</span>, <span class="number">8</span>)</div><div class="line">                ngx.say(<span class="string">"STORED"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        location /get &#123;</div><div class="line">            content_by_lua_block &#123;</div><div class="line">                <span class="keyword">local</span> dogs = ngx.shared.dogs</div><div class="line">                ngx.say(dogs:get(<span class="string">"Jim"</span>))</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lrucache的使用方法如<a href="https://github.com/openresty/lua-resty-lrucache" target="_blank" rel="external">文档所示</a>。</p>
<h3 id="Kong里的多级缓存实现"><a href="#Kong里的多级缓存实现" class="headerlink" title="Kong里的多级缓存实现"></a>Kong里的多级缓存实现</h3><p>有了上面的了解，看database_cache.lua这个文件就比较直观了，这里Kong会分多类缓存: apis, consumers, plugins等。具体这样分是因为如果我们对配置做了修改，需要发出serf消息来指名这次改动涉及到哪些，其他Kong节点收到消息后自然只更新对应的缓存部分。所以Kong里申明了一个列表CACHE_KEYS来存要缓存的数据类别，同时写了不少生成缓存key的方法，比如: api_key，plugin_key等。</p>
<p>仔细查看database_cache.lua，我们发现其实这里是做了两级缓存。Kong要从缓存里取出一个key/value，首先从lrucache里取，如果有则返回。如果没有则从share dict里去取，如果取到则deserialize然后存储在lrucache里，然后返回。如果shared dict里也没有，则返回nil。标准的两级缓存流程，这样做的好处在于减少deserialize的次数，而且shared dict可能被多个worker同时修改，要修改的时候需要加互斥锁。</p>
<p>这里最常用的方法是get_or_set，尝试获取一个key的值，如果没有就执行对应的callback，返回结果当做value设置到缓存里，并把value作为最后的返回结果。这里的callback函数通常做的当然是从数据库里读取内容。</p>
<h3 id="如何避免缓存失效风暴"><a href="#如何避免缓存失效风暴" class="headerlink" title="如何避免缓存失效风暴"></a>如何避免缓存失效风暴</h3><p>我们在实现缓存的时候<a href="http://www.sobstel.org/blog/preventing-dogpile-effect/" target="_blank" rel="external">缓存失效风暴问题</a>需要谨慎考虑。agentzh在这里详细描述了<a href="https://github.com/openresty/lua-resty-lock" target="_blank" rel="external">加锁解决的策略</a>，<a href="https://github.com/mtourne/ngx.shcache" target="_blank" rel="external">ngx.shcache</a>这里也使用了相同的方法，具体可以好好研究一下那个图。</p>
<p>主要注意的是在加锁后，再尝试去读取一次key，因为可能在加锁之前其他worker刚好把数据更新到了缓存里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nginx里的缓存使用&quot;&gt;&lt;a href=&quot;#Nginx里的缓存使用&quot; class=&quot;headerlink&quot; title=&quot;Nginx里的缓存使用&quot;&gt;&lt;/a&gt;Nginx里的缓存使用&lt;/h3&gt;&lt;p&gt;在Kong里面我们缓存的内容大部分是配置，不管是API本身的配置还是
    
    </summary>
    
    
      <category term="Lua" scheme="http://cyukang.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Kong源码分析: 插件</title>
    <link href="http://cyukang.com/2017/07/16/kong-intro-3.html"/>
    <id>http://cyukang.com/2017/07/16/kong-intro-3.html</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2017-07-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="插件的强大之处"><a href="#插件的强大之处" class="headerlink" title="插件的强大之处"></a>插件的强大之处</h3><p>在我自己使用 Kong 的过程中，最方便的还是在于 Kong 的强大的插件机制。 Nginx 本身提供了提供模块开发机制，但是相对来说更底层一些，并且需要使用 C/C++ 来开发，对于很多开发人员来说 Nginx 仍为一个黑盒。OpenResty 集成了很多好用插件，并提供了通过 Lua 扩展 Nginx 的机制，所以 OpenResty 相对来说更灵活。而 Kong 在 OpenResty 基础上提供的插件机制更灵活，在于： </p>
<blockquote>
<p>​        复用：OpenResty 的复用在于函数级别，我们可以把一些通用的 Lua 函数引入各个项目。而 Kong 的插件复用可以通过 API 修改一下配置即可。是否启用某个插件，这只是数据配置问题，启用与否不会涉及到代码的改动。</p>
<p>抽象、统一: Kong 实现了基础的插件配置的存储和更新机制，所以我们只需按照要求定义插件配置的数据类型，插件实现的时候不用再去关心这些细节。</p>
<p>灵活、组合: OpenResty 的一些处理部分有限制，比如 access_by_lua 在同一个 location 能调用一次， 当然我们可以把多个处理逻辑都放在这里，这又涉及到代码改动。 而 Kong 可以依次调用各个插件对应的 phase，并且通过引入优先级来解决前后顺序问题。</p>
</blockquote>
<p>插件开发的原则是提供机制，而非实现，在做插件开发的时候一定需要考虑这个插件能否满足一类相似的需求，这样我们只需要做一下参数的配置就能把插件启动在另外一个站点上。</p>
<p>对于插件这块我的疑问在于这套机制如何运行的？如何找到站点对应的插件？如此多的插件是否会有性能问题？​</p>
<h3 id="Kong插件的运行机制"><a href="#Kong插件的运行机制" class="headerlink" title="Kong插件的运行机制"></a>Kong插件的运行机制</h3><p>在上一文 Kong 初始化分析中，我们看到 nginx_kong.lua 模板文件里面有这么一段代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">location / &#123; </div><div class="line">  rewrite_by_lua_block &#123;</div><div class="line">      kong.rewrite()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  access_by_lua_block &#123;</div><div class="line">      kong.access()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  header_filter_by_lua_block &#123;</div><div class="line">      kong.header_filter()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  body_filter_by_lua_block &#123;</div><div class="line">      kong.body_filter()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  log_by_lua_block &#123;</div><div class="line">      kong.<span class="built_in">log</span>()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 kong.lua 文件里面， kong.access 的实现是这样的:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Kong.access</span><span class="params">()</span></span></div><div class="line">  core.access.before()</div><div class="line"></div><div class="line">  <span class="keyword">for</span> plugin, plugin_conf <span class="keyword">in</span> </div><div class="line">      plugins_iterator(singletons.loaded_plugins, <span class="literal">true</span>) <span class="keyword">do</span></div><div class="line">    plugin.handler:access(plugin_conf)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  core.access.after()</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>从这里可以看出 Kong 的插件运行机制就是从 loaded_plugins 里面依次执行。 学习 Kong 插件开发的方法是参考现有的一些插件实现，学着写几个就会了。用户自己定义的插件是在 base_plugin 基类上继承而来。Kong 里面使用的了<a href="https://github.com/rxi/classic" target="_blank" rel="external"> 这套 class 机制</a>，可以看到使用 Lua 实现面向对象还是很简单的。</p>
<h3 id="singletons-loaded-plugins"><a href="#singletons-loaded-plugins" class="headerlink" title="singletons.loaded_plugins"></a>singletons.loaded_plugins</h3><p><a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/kong.lua#L156" target="_blank" rel="external">singletons.loaded_plugins</a>在这里初始化的，在具体<a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/kong.lua#L70" target="_blank" rel="external">实现过程中</a>就是从数据库里面把插件配置读出，</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="keyword">local</span> ok, handler = utils.load_module_if_exists(<span class="string">"kong.plugins."</span> .. plugin .. <span class="string">".handler"</span>)</div></pre></td></tr></table></figure>
<p> 在每一个插件在 handler.lua 的最后都是 return XXXXHandler，所以在调用 <a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/kong.lua#L105" target="_blank" rel="external">handler()</a>后我们在内存中导入了插件的对象。另外在初始化后需要<a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/kong.lua#L116" target="_blank" rel="external">按照优先级来排序</a>，以此来保证各个插件之间的执行顺序。</p>
<p>从上面的分析上看出，插件导入后都会在内存中的全局对象中存储，后面的开销在于依次迭代插件。</p>
<h3 id="plugins-iterator"><a href="#plugins-iterator" class="headerlink" title="plugins_iterator"></a>plugins_iterator</h3><p>我们再来看看某个站点是否启用某个插件是如何处理的，最主要的实现在于 plugins_iterator 这个函数。首先我们得理解如何确定当前 request 对应的唯一标识符， 在<a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/core/handler.lua#L128" target="_blank" rel="external">core.handler.access</a>的过程中保存了经过路由后的 api在ngx.ctx 里，这个 ngx.ctx 会在整个request 处理过程中反复被使用。再回到 plugins_interator 函数，这个函数的参数有两个，后一个叫access_or_cert_ctx， 因为对于一个 request处理中 plugins_iterator 会调用多次，这个参数的作用在于判断是否是第一个调用这个函数。第一次调用可能发生在<a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/kong.lua#L219" target="_blank" rel="external">ssl_certificate</a>或者<a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/kong.lua#L297" target="_blank" rel="external">access</a> 阶段， 因为在 ctx 里面 Kong 还是初始化了一个叫做<code>ctx.plugins_for_request</code>的变量来存储当前 request 启用的插件，这样后续 iterator 阶段就完全不会去重复 load 插件配置，这样做当然是为了性能上的考虑。</p>
<p>读取插件配置的函数调用是： </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> api <span class="keyword">then</span></div><div class="line">   plugin_configuration = load_plugin_configuration(api.id, consumer_id, plugin.name)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/core/plugins_iterator.lua#L38" target="_blank" rel="external">load_plugin_configuration</a>也会首先尝试从内存缓存中取，如果取不到再从数据库中取出，然后存储在缓存中。</p>
<p>从上面的分析看出，插件相关的读取和执行在大部分时间里是完全不会去读数据库的，所以性能损失并不会大。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Kong的插件部分并没有错误处理部分，从现有代码上看错误处理分两个部分:</p>
<p>一种方式是<a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/tools/responses.lua" target="_blank" rel="external">responses.lua</a>， 如果是在 Kong 的 Lua 代码部分检查出来的错误一般使用类似<a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/kong.lua#L250" target="_blank" rel="external">responses.send(500)</a>这样的方式来向客户端返回错误码。</p>
<p>第二种是通过 <a href="https://github.com/chenyukang/kong/blob/blog-ref/kong/templates/nginx_kong.lua#L81" target="_blank" rel="external">kong_error_handler</a>。 这种错误可能是执行了 ngx.exit(500) 之类的代码或者是 Nginx 内部触发的。</p>
<p>这在某些情况下对用户不友好，我们不能只简单地返回一个错误信息，有的时候我们需要展示一个漂亮些的错误页面或者是把请求转到别的降级站点，对于这个需求我做了<a href="https://github.com/chenyukang/kong/tree/custom-error-handle" target="_blank" rel="external">一个分支来扩展错误处理</a>。 目前实现还未完整，不过已经可以定制化错误页面了。 这里增加了一个 <a href="https://github.com/chenyukang/kong/blob/custom-error-handle/kong/templates/nginx_kong.lua#L113" target="_blank" rel="external">ngx.var.api_id</a>，这个变量的初始化也在 <a href="https://github.com/chenyukang/kong/blob/60c934c851f41dfd6a921995a2568905284af742/kong/core/handler.lua#L98" target="_blank" rel="external">core.access 阶段</a>。因为存储在 ngx.ctx 里的这些信息在执行了 ngx.exit 之后已经释放了，所以我需要一个 ngx.var 级别的变量存储 api_id，然后使用这个变量来判断 error-handler 插件是否启用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;插件的强大之处&quot;&gt;&lt;a href=&quot;#插件的强大之处&quot; class=&quot;headerlink&quot; title=&quot;插件的强大之处&quot;&gt;&lt;/a&gt;插件的强大之处&lt;/h3&gt;&lt;p&gt;在我自己使用 Kong 的过程中，最方便的还是在于 Kong 的强大的插件机制。 Nginx 本身提
    
    </summary>
    
    
      <category term="Lua" scheme="http://cyukang.com/tags/Lua/"/>
    
  </entry>
  
</feed>
