<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cyukang.com/"/>
  <updated>2019-01-06T16:37:03.281Z</updated>
  <id>http://cyukang.com/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Markown 编辑公众号方法</title>
    <link href="http://cyukang.com/2019/01/06/wechat-tools.html"/>
    <id>http://cyukang.com/2019/01/06/wechat-tools.html</id>
    <published>2019-01-06T15:48:39.000Z</published>
    <updated>2019-01-06T16:37:03.281Z</updated>
    
    <content type="html"><![CDATA[<p>技术人员很多都喜欢使用 Markdown 格式来编辑文档，但是公众号后台默认不支持。</p>
<p>所以关于工具和流程，最近我摸索出来目前最适合自己的一套是：</p>
<p>还是维护之前 Hexo 那套，像代码那样使用 Git 管理，内容会上传到 Github 上。</p>
<p>继续使用 Typora 编辑 Markdown 文件。注意使用图片工具 IPic 来方便地把图片上传到图床上，其实免费的微博图床就足够。然后使用在线的转换工具<a href="http://md.codingpy.com/" target="_blank" rel="external">md.codingpy.com</a>即可很方便地把 Markdown 转成适合公众号的内容，复制粘贴到后台编辑器里。</p>
<p>这样在个人网站和公众号里都会有相同的内容，而且格式之类的都比较统一。</p>
<p>这里再次推荐 Typora: <a href="https://typora.io/" target="_blank" rel="external">https://typora.io/</a> 这个工具，会让人特别有写东西的冲动。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyxb4230duj310u0kmjs7.jpg" alt="image-20190106235957370"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;技术人员很多都喜欢使用 Markdown 格式来编辑文档，但是公众号后台默认不支持。&lt;/p&gt;
&lt;p&gt;所以关于工具和流程，最近我摸索出来目前最适合自己的一套是：&lt;/p&gt;
&lt;p&gt;还是维护之前 Hexo 那套，像代码那样使用 Git 管理，内容会上传到 Github 上。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开始写公众号</title>
    <link href="http://cyukang.com/2019/01/04/try-wechat-blog.html"/>
    <id>http://cyukang.com/2019/01/04/try-wechat-blog.html</id>
    <published>2019-01-04T14:57:24.000Z</published>
    <updated>2019-01-06T16:31:20.103Z</updated>
    
    <content type="html"><![CDATA[<p>2018 过得很快，对于自己来说有点颓废、也很辛苦。说是颓废因为花了一些时间在游戏上，还有不少焦虑。最近看书，翻到胡适 1932 年一篇《寄语即将毕业的大学生》中写到，人到社会容易丢掉求知的欲望、抛弃学生时代的理想追求，为了防止堕落文中给出三点建议。读来觉得颇有道理，这三点建议放在现在也合适： </p>
<blockquote>
<p>总得时时寻一两个值得研究的问题</p>
<p>总得多发展一点非职业的兴趣</p>
<p>你总得有一点信心</p>
</blockquote>
<p>新的一年想着尝试做些改变，逼着自己再做一些其他尝试，不然生活除了工作和日常，真是过得有些索然无趣了。业余写些东西是很好的积累，从 2006 年左右开始一直都有写博文的习惯，从搜狐、Yo2、WordPress， 一直到后来的  Hexo 托管到 Github 上。个人域名 <a href="http://cyukang.com">http://cyukang.com</a> 用了多年，其中的文章大概也有 140 来篇。在这么多年写博客的过程中收获不少，认识了一些朋友，也锻炼了自己的文字能力。</p>
<p>平台和工具一直在变化，文字只是一种表达的方式，能写出来还是得靠自己平时所想、所做。之前写的技术类的文章偏多，因此一直觉得公众号这种生态圈有些封闭，不利于检索。不过终究是大众的选择，公众号里好的内容也很多。如果要逼着自己写，有些人看、有些互动自然是更好的。不求有多少关注，但愿自己能坚持多写写而已。</p>
<p>关于写什么，我也还不太清楚。在技术方面可能涉猎较多，精通的不算多。总之算得上技术爱好者，还未丢掉这块兴趣。所以这里多是关于工作、技术的一些学习总结、实践等。把技术相关的东西写得通俗易懂绝非易事，希望在这方面能有更多进步。另外我更想拓展自己在其他方面的知识和积累，所以公众号上会写更多读书笔记和思考。『构成我们学习的最大阻碍是已知的东西，而非未知』，局限于技术角度并非好事。</p>
<p>关于公众号名字『递归说』，这是乱想的，刚好在取名的时候想到了而已。听起来比较好念，而且递归真是计算机里一个很简洁、优美的概念，也是解决问题的一种方法，还可以延伸理解为『自我进化』吧。人这一辈子不也像一个递归么，过一年就像过了一个迭代，而且都是有终点的。</p>
<p>先写起来再继续摸索找方向吧，总得对自己有些信心。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fyv11g49sjj30zk0sgter.jpg" alt="134871342111"></p>
<p>扫描关注： </p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fyvm0wf0tmj309k09kjrc.jpg" alt="qrcode_for_gh_5f51bbbd18c0_344"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 过得很快，对于自己来说有点颓废、也很辛苦。说是颓废因为花了一些时间在游戏上，还有不少焦虑。最近看书，翻到胡适 1932 年一篇《寄语即将毕业的大学生》中写到，人到社会容易丢掉求知的欲望、抛弃学生时代的理想追求，为了防止堕落文中给出三点建议。读来觉得颇有道理，这三点
    
    </summary>
    
    
      <category term="WeChat" scheme="http://cyukang.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>编译脚本到二进制</title>
    <link href="http://cyukang.com/2019/01/01/compile-script-to-binary-for-obfuscation.html"/>
    <id>http://cyukang.com/2019/01/01/compile-script-to-binary-for-obfuscation.html</id>
    <published>2019-01-01T14:55:22.000Z</published>
    <updated>2019-01-04T14:46:57.972Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>因为自己习惯使用 expect 脚本登录各种服务器，有一段时间因为要登录的服务器太多了，所以之前写过一个程序来管理各种 expect 脚本。实现思路是根据配置文件，用一个程序来动态生成脚本，执行完之后再删除。这样临时生成的文件里也是包含密码等信息的。最近突然想是不是可以直接写一个程序，把所有脚本类的程序转换为二进制可执行文件<a href="https://www.slideshare.net/LizBaillie/rustconf-2016-illustrated-adventure-guide-65894363" target="_blank" rel="external">^image</a>。我不想把密码之类的直接写在固定的脚本里面，所以密码也是被编译在可执行的二进制文件里的，这样能达到一些代码混淆的目的。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fyuxr5d6y5j30yg0j6gsy.jpg" alt="image-20190101234053094"></p>
<h3 id="rshc-的开发"><a href="#rshc-的开发" class="headerlink" title="rshc 的开发"></a>rshc 的开发</h3><p>这个程序看起来有些好玩，所以先我先搜了一下是否之前有其他人这样做过。于是找到了 <a href="https://github.com/neurobin/shc" target="_blank" rel="external">shc</a> 这个开源程序，这个最初版本是 96 年用 C 写的，最终执行的时候还是用 execvp 调用解释器执行各种脚本。我使用了一下发现居然不支持 expect 之类的。然后想着自己写个玩玩，顺便再动手用用最近看得又心痒的 Rust，最后用搞出来一个初版: <a href="https://github.com/chenyukang/rshc" target="_blank" rel="external">rhsc</a>。</p>
<p>目前我这个程序只是能把脚本程序，转换为 Rust 代码，然后使用 rustc 来编译为二进制，为了做一些代码混淆，其中也类似 shc 使用了 RC4 算法来做了一个简单的转换，加密用的 key 是随机生成的。然后也做了另外一个增加密码的模式，这样可以为任何脚本增加密码校验功能，最终使用 <a href="https://doc.rust-lang.org/beta/std/process/struct.Command.html" target="_blank" rel="external">Process</a> 来执行解释器。当然也谈不上多安全，如果要破解可以使用一些类似 ptrace 或者<a href="https://github.com/neurobin/shc/issues/63" target="_blank" rel="external">其他方式</a>来试试。以后我会继续完善这方面的防御。另外，为了在生成代码之后尽量减少依赖，所以目前密码输入时还未做到隐藏输入。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>使用方式非常简单，先安装：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">cargo install rshc</div></pre></td></tr></table></figure>
<p>然后使用命令： </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rshc -f demo.sh -o demo.rs</div><div class="line"></div><div class="line">/<span class="regexp">/ add a passowrd when compile it, </span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ then binary will prompt for correct password before execution</span></div><div class="line"><span class="regexp">rshc -f demo.sh -o demo.rs -p</span></div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>时隔两年再用 Rust 写一些小项目，发现整个语言还是成熟很多：</p>
<ul>
<li>工具链很好用，特别是 cargo 之类的，<a href="https://crates.io/crates/rshc" target="_blank" rel="external">从开发到发布都非常方便</a></li>
<li>相关的库和文档也多了起来，相对来说更加容易上手写一些东西了</li>
<li>编译器的错误提示特别好，可以通过错误索引号找到示例</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h3&gt;&lt;p&gt;因为自己习惯使用 expect 脚本登录各种服务器，有一段时间因为要登录的服务器太多了，所以之前写过一个程序来管理各种 expect 脚本。
    
    </summary>
    
    
      <category term="Rust" scheme="http://cyukang.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>SQL Injection attack</title>
    <link href="http://cyukang.com/2018/03/10/sql-injection-attack.html"/>
    <id>http://cyukang.com/2018/03/10/sql-injection-attack.html</id>
    <published>2018-03-10T12:51:40.000Z</published>
    <updated>2019-01-01T15:22:48.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h3><p>SQL注入一直是 Web 应用的一大安全隐患，注入的基本原理是通过修改输入的参数来操作后台执行的 SQL，注入可能会导致数据库被恶意修改、数据被恶意读取等严重行为。所以如果一个参数有漏洞，通过小心的构造注入点即可利用，这里的<a href="https://paper.seebug.org/15/" target="_blank" rel="external">渗透攻防Web篇-SQL注入攻击初级</a>有一些编写注入点的教程。</p>
<p>最初的时候我在一个用 C 写后台的项目里待过，现在回想起来我们当时根本没注意SQL 注入，C 拼接处 SQL 的字符串很常见。不过现在大多数 Web 框架都已经有 ORM 了，ORM 可以在很大程度上避免注入的产生，因为程序员通常来说不用写纯的 SQL 了， 在最佳实践的前提下 ORM 会生成安全的 SQL。当然什么工具最终还是依赖程序员，比如下面的 Ruby 代码即会有问题: </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">User.where(<span class="string">"email = <span class="subst">#&#123;params[<span class="symbol">:email</span>]&#125;</span>"</span>).first</div></pre></td></tr></table></figure>
<p>更多作死的办法可以参考： <a href="https://rails-sqli.org/" target="_blank" rel="external">https://rails-sqli.org/</a></p>
<h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>通常我们会使用一些 WAF 来阻挡 一些SQL 注入，但是 WAF 也有其局限性。WAF 一般是通用的，不会局限于某个特定的框架。我们可以实现在 Nginx 上，或者使用一些商用的 WAF，通常来说对于应用也不用修改其代码。不过 WAF 的问题在于其实基于规则的，而 SQL 本省是比较复杂的，可以看看<a href="https://github.com/ronsavage/SQL/blob/master/sql-2003-2.bnf" target="_blank" rel="external">2003 SQL BNF</a> 的描述有多么的长。所以 WAF 的规则大多数是一大堆较难维护的正则表达式，比如： <a href="https://github.com/unixhot/waf/blob/master/waf/rule-config/args.rule" target="_blank" rel="external">Nginx Waf示例</a>，注意这个项目用不太成熟，初步看会有比较严重的<a href="https://github.com/unixhot/waf/issues/12" target="_blank" rel="external">性能问题</a>。正因为规则是固定的，会导致存在很多误拦截的情况，所以我在 Kong 上实现的 WAF 就还不敢用起来。例如现实情况中出现过<a href="https://store.dji.com/select" target="_blank" rel="external">包含select的 uri</a>被拦的情况，一脸忧伤。</p>
<h3 id="静态代码扫描"><a href="#静态代码扫描" class="headerlink" title="静态代码扫描"></a>静态代码扫描</h3><p>静态代码扫描会发现一些 SQL 注入，比如  Brakeman 之类的。不过通常静态代码扫描的问题也是分析得不够精准，会漏报、也会出现误报比较多，扫描的结果需要进行人工审计。当然这些工具也在逐步改进。</p>
<h3 id="RASP-工具"><a href="#RASP-工具" class="headerlink" title="RASP 工具"></a>RASP 工具</h3><p>RASP 的意思是<a href="https://www.veracode.com/security/runtime-application-self-protection-rasp" target="_blank" rel="external">Runtime Application Self Protection</a>，这个概念近些年才提出，目前已经有一些安全公司做出了对应的产品，比如<a href="http://www.sqreen.io" target="_blank" rel="external">Sqreen</a>, 百度最近也新开一个开源项目叫做<a href="https://github.com/baidu/openrasp" target="_blank" rel="external">OpenRASP</a>，目前来说只支持 Java，开发者可以自己使用 Javascript 编写自己的插件。RASP 除了自己的规则还会依据请求时候的上下文来进行分析，这篇文章里有<a href="https://blog.sqreen.io/block-sql-injections-not-customers/" target="_blank" rel="external">一些描述</a>，这样误报的问题会大大减少。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;注入原理&quot;&gt;&lt;a href=&quot;#注入原理&quot; class=&quot;headerlink&quot; title=&quot;注入原理&quot;&gt;&lt;/a&gt;注入原理&lt;/h3&gt;&lt;p&gt;SQL注入一直是 Web 应用的一大安全隐患，注入的基本原理是通过修改输入的参数来操作后台执行的 SQL，注入可能会导致数据
    
    </summary>
    
    
      <category term="security" scheme="http://cyukang.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Kong集群Left Cluster Node问题</title>
    <link href="http://cyukang.com/2018/03/04/kong-cluster-left-node.html"/>
    <id>http://cyukang.com/2018/03/04/kong-cluster-left-node.html</id>
    <published>2018-03-04T03:02:32.000Z</published>
    <updated>2018-03-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Kong在实践中会有一些疑惑的地方，这里记录一下。注意这里记录的Kong集群部署的问题是0.10.3版本的，最新Kong版本已经不是通过serf来管理不同节点之间的配置同步问题。</p>
<p>在Kong多节点部署的时候，有时候某个节点停掉后，我们在后台可以看到left的信息，而且这个left信息会保留一段不短的时间。类似于如下： </p>
<p><img src="/images/kong-left-0133521.png" alt="kong-left"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>管理后台Konga是通过api获取的节点信息，在<code>kong/kong/api/routes/cluster.lua</code>文件里可以看到如下路由处理逻辑： </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">GET = <span class="function"><span class="keyword">function</span><span class="params">(self, dao_factory, helpers)</span></span></div><div class="line">  <span class="keyword">local</span> members, err = singletons.serf:members()</div><div class="line">  <span class="keyword">if</span> err <span class="keyword">then</span></div><div class="line">    <span class="keyword">return</span> responses.send_HTTP_INTERNAL_SERVER_ERROR(err)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="keyword">local</span> result = &#123;data = &#123;&#125;&#125;</div><div class="line">  <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(members) <span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.params.<span class="built_in">status</span> <span class="keyword">or</span> (self.params.<span class="built_in">status</span> <span class="keyword">and</span> v.<span class="built_in">status</span> == self.params.<span class="built_in">status</span>) <span class="keyword">then</span></div><div class="line">      table_insert(result.data, &#123;</div><div class="line">        name = v.name,</div><div class="line">        address = v.addr,</div><div class="line">        <span class="built_in">status</span> = v.<span class="built_in">status</span></div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  result.total = #result.data</div><div class="line">  <span class="keyword">return</span> responses.send_HTTP_OK(result)</div><div class="line"><span class="keyword">end</span>,</div></pre></td></tr></table></figure>
<p>具体<code>serf:members()</code>的实现在serf.lua里面可以看到，就是执行了<code>serf cluster members</code>命令获取结果然后返回JSON。所以我们在服务器上执行这个命令其实也可以看到类似的结果： </p>
<p><img src="/images/kong-left-cmd.png" alt="kong-left-cmd"></p>
<p>那么问题的根源当然是在Serf本身里面，通过看文档发现原来确实是有一定延迟的。</p>
<blockquote>
<p>Serf keeps the state of dead nodes around for a set amount of time, so that when full syncs are requested, the requester also receives information about dead nodes. Because SWIM doesn’t do full syncs, SWIM deletes dead node state immediately upon learning that the node is dead. This change again helps the cluster converge more quickly.</p>
<p><a href="https://www.serf.io/docs/internals/gossip.html#lifeguard-enhancements" target="_blank" rel="external">参考serf文档»</a></p>
</blockquote>
<h4 id="serf的具体实现"><a href="#serf的具体实现" class="headerlink" title="serf的具体实现"></a>serf的具体实现</h4><p>接着稍微看了一下Serf的代码，果然Go的项目代码直观好读。在Serf这个结构体里面保存了一个leftMembers的状态列表，每次收到left事件的时候处理逻辑是： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// handleNodeLeaveIntent is called when an intent to leave is received.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Serf)</span> <span class="title">handleNodeLeaveIntent</span><span class="params">(leaveMsg *messageLeave)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	..................</div><div class="line">    </div><div class="line">	<span class="comment">// State transition depends on current state</span></div><div class="line">	<span class="keyword">switch</span> member.Status &#123;</div><div class="line">	<span class="keyword">case</span> StatusAlive:</div><div class="line">		member.Status = StatusLeaving</div><div class="line">		member.statusLTime = leaveMsg.LTime</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	<span class="keyword">case</span> StatusFailed:</div><div class="line">		member.Status = StatusLeft</div><div class="line">		member.statusLTime = leaveMsg.LTime</div><div class="line"></div><div class="line">		<span class="comment">// Remove from the failed list and add to the left list. We add</span></div><div class="line">		<span class="comment">// to the left list so that when we do a sync, other nodes will</span></div><div class="line">		<span class="comment">// remove it from their failed list.</span></div><div class="line">		s.failedMembers = removeOldMember(s.failedMembers, member.Name)</div><div class="line">		s.leftMembers = <span class="built_in">append</span>(s.leftMembers, member)</div><div class="line">        </div><div class="line">        ................</div><div class="line">        </div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过索引变量发现这个列表会定时通过<code>handleReap</code>函数更新，逻辑如下： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// handleReap periodically reaps the list of failed and left members, as well</span></div><div class="line"><span class="comment">// as old buffered intents.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Serf)</span> <span class="title">handleReap</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-time.After(s.config.ReapInterval):</div><div class="line">			s.memberLock.Lock()</div><div class="line">			now := time.Now()</div><div class="line">			s.failedMembers = s.reap(s.failedMembers, now, s.config.ReconnectTimeout)</div><div class="line">			s.leftMembers = s.reap(s.leftMembers, now, s.config.TombstoneTimeout)</div><div class="line">			reapIntents(s.recentIntents, now, s.config.RecentIntentTimeout)</div><div class="line">			s.memberLock.Unlock()</div><div class="line">		<span class="keyword">case</span> &lt;-s.shutdownCh:</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以看起来这里相关的Timeout是<code>s.config.TombstoneTimeout</code>, 接着需要看看<code>reap</code>到底做了什么，这里果然是把到了一定时间间隔的节点删掉了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// reap is called with a list of old members and a timeout, and removes</span></div><div class="line"><span class="comment">// members that have exceeded the timeout. The members are removed from</span></div><div class="line"><span class="comment">// both the old list and the members itself. Locking is left to the caller.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Serf)</span> <span class="title">reap</span><span class="params">(old []*memberState, now time.Time, timeout time.Duration)</span> []*<span class="title">memberState</span></span> &#123;</div><div class="line">	n := <span class="built_in">len</span>(old)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</div><div class="line">		m := old[i]</div><div class="line"></div><div class="line">		<span class="comment">// Skip if the timeout is not yet reached</span></div><div class="line">		<span class="keyword">if</span> now.Sub(m.leaveTime) &lt;= timeout &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Delete from the list</span></div><div class="line">		old[i], old[n<span class="number">-1</span>] = old[n<span class="number">-1</span>], <span class="literal">nil</span></div><div class="line">		old = old[:n<span class="number">-1</span>]</div><div class="line">		n--</div><div class="line">		i--</div><div class="line"></div><div class="line">		..........</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> old</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这个时间间隔是多久呢，在<code>serf/config.go</code>有一个默认配置： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">TombstoneTimeout:             <span class="number">24</span> * time.Hour,</div></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>serf这个软件值得好好分析一下，节点的状态同步和事件处理都是分布式软件的基础，后续继续看看这个<code>gossip protocol based on SWIM</code>的具体实现。另外<a href="https://www.hashicorp.com/" target="_blank" rel="external">hashicorp</a>这个公司的开源代码和文档都非常好，值得学习一番。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;Kong在实践中会有一些疑惑的地方，这里记录一下。注意这里记录的Kong集群部署的问题是0.10.3版本的，最新Kong版本已经不是通过se
    
    </summary>
    
    
      <category term="Tools" scheme="http://cyukang.com/tags/Tools/"/>
    
      <category term="Kong" scheme="http://cyukang.com/tags/Kong/"/>
    
      <category term="Golang" scheme="http://cyukang.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Docker compose初始化失败问题</title>
    <link href="http://cyukang.com/2018/03/02/docker-postgres-password.html"/>
    <id>http://cyukang.com/2018/03/02/docker-postgres-password.html</id>
    <published>2018-03-02T15:17:35.000Z</published>
    <updated>2018-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>今天在Docker Postgresql用户名和密码授权的问题上花了一些时间，问题是： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">psql: FATAL:  password authentication failed for user "postgres"</div></pre></td></tr></table></figure>
<p>admin的用户名和密码是可以在docker-compose.yml里设置的，通常我们可以配置为： </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">postgresql:</span></div><div class="line"><span class="attr">  image:</span> <span class="attr">postgres:latest</span></div><div class="line"><span class="attr">  ports:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"5434:5432"</span></div><div class="line"><span class="attr">  volumes:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">./data/pgsql:/var/lib/postgresql/data</span></div><div class="line"><span class="bullet">    -</span> <span class="string">./initialize/pgsql:/docker-entrypoint-initdb.d</span></div><div class="line"><span class="attr">  environment:</span></div><div class="line"><span class="attr">    POSTGRES_USER:</span> <span class="string">postgres</span></div><div class="line"><span class="attr">    POSTGRES_DB:</span> <span class="string">postgres</span></div><div class="line"><span class="attr">  secrets:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">pg_superuser_password</span></div></pre></td></tr></table></figure>
<p>某个用户的密码可以在<code>./initialize/pgsql</code>目录的脚本里设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></div><div class="line">set -e</div><div class="line"></div><div class="line">psql -v ON_ERROR_STOP=1 --username "postgres" &lt;&lt;-EOSQL</div><div class="line">	CREATE USER user WITH PASSWORD 'the-password';</div><div class="line">	ALTER USER user CREATEDB;</div><div class="line">EOSQL</div></pre></td></tr></table></figure>
<p>只是今天碰巧想修改一下这个密码，所以就把这个脚本里的密码修改了，然后执行命令： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">docker-compose up --build -d --force-recreate</div></pre></td></tr></table></figure>
<p>而后就一直出现上面的用户授权失败。</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>刚开始一直认为是可能dockerfile配置得不对，结果花费了些时间。后来突然想到了，PG里数据初始化应该只是第一次做了，后续如果发现<code>/var/lib/postgresql/data</code>里已经有数据了就再也不会重新设置密码，这里是配置volume的，如果还未有重要数据把<code>./data/pgsql</code>删除了即可，或者应该是可以通过attach进入容器通过pg命令修改。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最近在自己工作的项目都完全Docker化，感觉是配置来折腾用起来飞。最近也在做一个重度依赖Docker的项目，所以Docker的文档需要看完，特别是网络和数据存储那块，否则会花费不少时间折腾。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;今天在Docker Postgresql用户名和密码授权的问题上花了一些时间，问题是： &lt;/p&gt;
&lt;figure class=&quot;highli
    
    </summary>
    
    
      <category term="Tools" scheme="http://cyukang.com/tags/Tools/"/>
    
      <category term="Docker" scheme="http://cyukang.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用overcommit生成git hooks</title>
    <link href="http://cyukang.com/2018/02/26/overcommit.html"/>
    <id>http://cyukang.com/2018/02/26/overcommit.html</id>
    <published>2018-02-26T11:02:14.000Z</published>
    <updated>2018-02-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>git hooks</code>很方便地可以在git操作流程的各个阶段加入hooks，比如执行一些脚本来检查代码风格、跑单元测试、做代码静态检查等。git hooks的试用方法是在.git/hooks目录下写各种脚本，但是.git目录的这些脚本是不会checkin到repo里的，所以如果一个代码如果被多个开发人员共享就会显得不太方便同步hooks。</p>
<p><a href="https://stackoverflow.com/questions/427207/can-git-hook-scripts-be-managed-along-with-the-repository" target="_blank" rel="external">当然也有一些其他方法来解决这个问题</a>，比如配置links或者对于<code>git 2.9</code>以后也可以使用来定制hooks的目录:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">git config core.hooksPath hooks</div></pre></td></tr></table></figure>
<p>对于熟悉Ruby的同学可以使用<a href="https://github.com/brigade/overcommit" target="_blank" rel="external">overcommit</a>这个gem来解决。使用方法就是通过配置<code>.overcommit.yml</code>，比如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">PreCommit:</span></div><div class="line"><span class="attr">  RuboCop:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    command:</span> <span class="string">['bundle',</span> <span class="string">'exec'</span><span class="string">,</span> <span class="string">'rubocop'</span><span class="string">]</span> <span class="comment">#  The shell command should run</span></div><div class="line"></div><div class="line"><span class="attr">  AuthorName:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>然后执行命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">overcommit install</div></pre></td></tr></table></figure>
<p>来自动生成各种hooks，通常后面的修改都是修改这个yaml文件即可，不过记得修改后需要<code>overcommit --signed</code>来重新生成hooks。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git hooks&lt;/code&gt;很方便地可以在git操作流程的各个阶段加入hooks，比如执行一些脚本来检查代码风格、跑单元测试、做代码静态检查等。git hooks的试用方法是在.git/hooks目录下写各种脚本，但是.git目录的这些脚本是不会checki
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx https too many redirect</title>
    <link href="http://cyukang.com/2018/02/23/nginx-https-too-many-redirect.html"/>
    <id>http://cyukang.com/2018/02/23/nginx-https-too-many-redirect.html</id>
    <published>2018-02-23T09:38:44.000Z</published>
    <updated>2018-02-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Http请求在经过多层Nginx的时候，通常强制http跳转到https的时候会这样配置: </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">return</span> <span class="number">302</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>; </div><div class="line"><span class="comment">## 需要注意这里是request_uri而不是uri，否则会引起安全问题</span></div></pre></td></tr></table></figure>
<p>但是如果是多层Nginx，前面的Nginx需要把用户原始请求的scheme传递到后端，可以加上头部设置： </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</div></pre></td></tr></table></figure>
<p>后面的Nginx再判断一次:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">if</span> ( <span class="variable">$http_x_forwarded_proto</span> != <span class="string">'https'</span> ) &#123;</div><div class="line">  <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>否则强制https经常会出现类似<code>ERR_TOO_MANY_REDIRECTS 将您重定向的次数过多</code>这样的问题。</p>
<p>可是在实践过程中偶尔也碰到过一些ELB会丢掉scheme的问题，比如在这样的请求链路情况下<code>elb =&gt; nginx =&gt; nginx =&gt; application</code>第二层Nginx获取的scheme就有问题了，这也可能会导致<code>too many redirects</code>问题。</p>
<p>可以尝试在第二层Nginx上这样解决： </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">proxy_set_header</span>   X-Forwarded-Proto <span class="variable">$http_x_forwarded_proto</span>;</div></pre></td></tr></table></figure>
<p>当然强制https这样的跳转逻辑尽量放在请求链路的最外层，这样问题会少一些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Http请求在经过多层Nginx的时候，通常强制http跳转到https的时候会这样配置: &lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;sp
    
    </summary>
    
    
      <category term="Nginx" scheme="http://cyukang.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux 当前 shell 执行命令</title>
    <link href="http://cyukang.com/2018/02/22/linux-source.html"/>
    <id>http://cyukang.com/2018/02/22/linux-source.html</id>
    <published>2018-02-22T13:46:33.000Z</published>
    <updated>2018-02-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux shell 执行脚本的时候一般是会 fork 出一个子 shell，这样在有的时候就不方便了，比如要unset 当前shell 的环境变量等，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env zsh</span></div><div class="line"></div><div class="line">if [ -z $http_proxy ]; then</div><div class="line">    echo "not using proxy, set it now ... ";</div><div class="line">    export http_proxy="http://127.0.0.1:1087";</div><div class="line">    export https_proxy="https://127.0.0.1:1087";</div><div class="line">    echo $http_proxy;</div><div class="line">else</div><div class="line">    echo "using proxy now, unset it now ...";</div><div class="line">    unset http_proxy;</div><div class="line">    unset https_proxy;</div><div class="line">    echo $http_proxy;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>这时候需要执行 <code>. ./proxy_toggle.sh</code> 或者 <code>source ./proxy_toggle.sh</code>。</p>
<p><code>.</code> (a period) is a <a href="http://www.gnu.org/software/bash/manual/bashref.html#Bourne-Shell-Builtins" target="_blank" rel="external">bash shell built-in command</a> that executes the commands from a file passed as argument, in the current shell. <code>source</code> is a synonym for <code>.</code></p>
<p>From Bash man page:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">. filename [arguments]</div><div class="line">source filename [arguments]</div><div class="line"><span class="code">       Read  and  execute  commands  from filename in the current shell</span></div><div class="line"><span class="code">       environment and return the exit status of the last command  exe‐</span></div><div class="line"><span class="code">       cuted from filename.  If filename does not contain a slash, file</span></div><div class="line"><span class="code">       names in PATH are used to find the  directory  containing  file‐</span></div><div class="line"><span class="code">       name.   The  file  searched  for in PATH need not be executable.</span></div><div class="line"><span class="code">       When bash is  not  in  posix  mode,  the  current  directory  is</span></div><div class="line"><span class="code">       searched  if no file is found in PATH.  If the sourcepath option</span></div><div class="line"><span class="code">       to the shopt builtin command is turned  off,  the  PATH  is  not</span></div><div class="line"><span class="code">       searched.   If any arguments are supplied, they become the posi‐</span></div><div class="line"><span class="code">       tional parameters when  filename  is  executed.   Otherwise  the</span></div><div class="line"><span class="code">       positional  parameters  are unchanged.  The return status is the</span></div><div class="line"><span class="code">       status of the last command exited within the  script  (0  if  no</span></div><div class="line"><span class="code">       commands  are  executed),  and false if filename is not found or</span></div><div class="line"><span class="code">       cannot be read.</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux shell 执行脚本的时候一般是会 fork 出一个子 shell，这样在有的时候就不方便了，比如要unset 当前shell 的环境变量等，&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ruby的 open 函数导致命令执行</title>
    <link href="http://cyukang.com/2018/02/12/ruby-open-vul.html"/>
    <id>http://cyukang.com/2018/02/12/ruby-open-vul.html</id>
    <published>2018-02-12T12:39:46.000Z</published>
    <updated>2018-02-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>首先看看 open 函数的文档说明， <a href="https://apidock.com/ruby/v1_9_3_392/Kernel/open/class：" target="_blank" rel="external">https://apidock.com/ruby/v1_9_3_392/Kernel/open/class：</a> </p>
<blockquote>
<p>If <em>path</em> starts with a pipe character, a subprocess is created, connected to the <a href="https://apidock.com/ruby/Kernel/caller" target="_blank" rel="external">caller</a> by a pair of pipes. The returned <a href="https://apidock.com/ruby/IO" target="_blank" rel="external">IO</a> object may be used to write to the standard input and read from the standard output of this subprocess. If the command following the “|” is a single minus sign, Ruby forks, and this subprocess is connected to the parent. In the subprocess, the <a href="https://apidock.com/ruby/Kernel/open" target="_blank" rel="external">open</a> call returns nil. If the command is not “-”, the subprocess runs the command. If a block is associated with an <a href="https://apidock.com/ruby/Kernel/open" target="_blank" rel="external">open</a>(“|-”) call, that block will be run twice—once in the parent and once in the child. The block parameter will be an <a href="https://apidock.com/ruby/IO" target="_blank" rel="external">IO</a> object in the parent and nil in the child. The parent’s <a href="https://apidock.com/ruby/IO" target="_blank" rel="external">IO</a> object will be connected to the child’s stdin  and stdout. The subprocess will be terminated at the end of the block.</p>
</blockquote>
<p>其中说明了如果以|开头则会 fork 出一个进程，<code>|</code> 后面的内容则会当成一条命令执行，比如： </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">cmd = open(<span class="string">"|date"</span>)</div><div class="line">print cmd.gets</div><div class="line">cmd.close</div><div class="line">=&gt; <span class="number">2018</span>年 <span class="number">2</span>月<span class="number">12</span>日 星期一 <span class="number">21</span>时<span class="number">37</span>分<span class="number">45</span>秒 CST</div></pre></td></tr></table></figure>
<h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>正因为这样，这个 open 函数真的是很容易出错，最近的这个 PR： </p>
<p><a href="https://github.com/ruby/ruby/pull/1777" target="_blank" rel="external">https://github.com/ruby/ruby/pull/1777</a></p>
<p>之前我们的项目里也出现过类似的情况，直接相当于一个 webshell，任意执行命令。这样的 command injection 当然也很好检测，brakeman 之类的就可以。所以 Rails项目还是时不时地扫描一下比较好。</p>
<p>Ruby 里面有几个 Open，<a href="https://stackoverflow.com/questions/1727217/file-open-open-and-io-foreach-in-ruby-what-is-the-difference" target="_blank" rel="external">这里</a>有比较明晰的解释，Kernel.open 这个函数就是一个 wrapper，根据不同的情况做对应的处理。趟多了坑之后，才会觉得这样的特性其实是增加了程序员的负担，比如这个<code>|</code>特性可能有的人就没注意到，即使是看过文档也可能看到了<a href="https://apidock.com/ruby/v1_8_6_287/Kernel/open" target="_blank" rel="external">老版本的文档</a>，从而不知道这个边边角角。</p>
<p>当然同样的 system这样的命令执行函数也是类似的情况，比如<a href="https://github.com/OWASP/railsgoat/wiki/A1-Command-Injection" target="_blank" rel="external">railsgoat 里的这个 command injection</a>。原则是对于任何用户输入的参数，都需要做不安全的假设，做好检查。</p>
<p><a href="https://github.com/OWASP/railsgoat" target="_blank" rel="external">https://github.com/OWASP/railsgoat</a>这个项目里有各种 Rails漏洞，值得看看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;首先看看 open 函数的文档说明， &lt;a href=&quot;https://apidock.com/ruby/v1_9_3_392/Kernel
    
    </summary>
    
    
  </entry>
  
</feed>
