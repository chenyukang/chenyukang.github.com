<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyukang.github.io/"/>
  <updated>2020-10-09T14:09:32.014Z</updated>
  <id>http://chenyukang.github.io/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DHH - 关于软件开发的另类想法</title>
    <link href="http://chenyukang.github.io/2020/10/09/dhh-on-software-dev.html"/>
    <id>http://chenyukang.github.io/2020/10/09/dhh-on-software-dev.html</id>
    <published>2020-10-09T14:09:32.000Z</published>
    <updated>2020-10-09T14:09:32.014Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/" target="_blank" rel="external">David Heinemeier Hansson, Software Contrarian</a> 是 Podcast 频道 corecursive 在 2020.2.1 发布的一个 DHH 关于软件开发相关的访谈。</p>
<p>DHH 不用介绍了，Rails 创始人。</p>
<p>可以说之前 Ruby 的流行很大程度上依赖于 Rails 的兴起。Rails 确实影响了很多后来的 Web 框架的设计和实现，并给软件开发带了一些全新的理念。</p>
<p>这期是我之前当作练习英语的材料来听的。DHH 的口音非常清晰，表达方式也是非常直接。因此这期听起来有一种类似 Rap 的快感。</p>
<p><img src="/images/2020_10_01_dhh-software-contrarian.org_20201009_220930.png" alt="file:img/2020_10_01_dhh-software-contrarian.org_20201009_220930.png"></p>
<h2 id="为什么-Rails-成功了"><a href="#为什么-Rails-成功了" class="headerlink" title="为什么 Rails 成功了"></a>为什么 Rails 成功了</h2><p>Rails 的出现改变了软件开发，至少在 2006 年，当 Java，C# 大行其道的年代。Rails 以其优异的开发效率震惊了不少开发者。Rails 的成功无非是在恰好的时机做了恰当的事情。</p>
<p>DHH 总结了从 Java、PHP 的开发经验。Java 阵营里都是聪明人，有很多好想法，但是他们却在一个糟糕的开发环境里工作，不容易让新人轻易上手。而 PHP 却很简单明了，你直接把一个文件拖入特定的文件夹，就可以生成对应的网页。Rails 的第三个元素就是 Ruby，Ruby 是极其容易安装，容易上手而直接的编程语言。DHH 当时正在写 Basecamp，所以一切都是从实际使用出发的，自己构建工具，然后再用这个工具构建 Basecamp。</p>
<p>而且 DHH 当时也是一个 Ruby 新手(那时的 Ruby 老手估计也没几个?)</p>
<p>新手的好处在于，他不知道 Ruby 的极限在哪里，哪里可能面临挑战。这样可以随着自己的性子，满足自己的期望来构建 Rails 了。在写 Rails 的过程中，DHH 更关注的是作为用户的感受是什么？编程就像是做菜一样，厨子需要关注的色香味俱全。</p>
<p>Ruby 最大的洞见是: 程序员不仅仅是程序员，同时也是人。</p>
<p>依据这个原则，在设计 Ruby 中最重要的事情和设计标准就是：编程语言使程序员更快乐。</p>
<h2 id="最开始如何开始接触-Ruby"><a href="#最开始如何开始接触-Ruby" class="headerlink" title="最开始如何开始接触 Ruby"></a>最开始如何开始接触 Ruby</h2><p>Ruby 是日本人 Matz 于 1995。但是直到 2003，这门编程语言仍然是非常小众而神秘的。DHH 也是那段时间在看到些 Martin Fowler 和 Dave Thomas 写的技术文章，他们俩个都选择了 Ruby 作为编程语言介绍一些概念。这引起了 DHH 的兴趣，所以开始关注 Ruby，并去参加了 Ruby 2004 Conf。</p>
<p>那届 Conf 大约也就 42 人吧….</p>
<p>但是随后几年的 Rails Conf 就开始有 2500 人了。</p>
<h2 id="关于编程语言的选择"><a href="#关于编程语言的选择" class="headerlink" title="关于编程语言的选择"></a>关于编程语言的选择</h2><p><strong>很多程序员因为喜欢上编程，就是刚好碰到了符合自己口味的编程语言，并激发对编程的巨大乐趣</strong>。所以，语言的选择说不重要也不对。如果你还没找到自己的最爱，继续尝试吧。</p>
<p>但并不意味着，在一个小众的编程语言过多投资可能会带来其他的回报。语言的流行有很多其他的因素。Rails 的初衷并不是完全用来满足自己的创造轮子的快感的，而是依据自己的实际项目出发的。</p>
<p>这给我们的不错启示：从实际的需求出发，使用新的工具造轮子。</p>
<h2 id="关于微服务的吐槽"><a href="#关于微服务的吐槽" class="headerlink" title="关于微服务的吐槽"></a>关于微服务的吐槽</h2><p>DHH 对微服务保持否定态度，认为业界这么流行微服务其实是有害的。</p>
<p>大多数情况下，一个人可以完全理解、部署的单一应用，比微服务更容易维护。</p>
<p>微服务的优势在于，如果团队足够地大，我们需要给开发者一些界限。</p>
<p>不要盲目地沿用大公司的套路，因为解决的问题不同！</p>
<h2 id="关于-TDD"><a href="#关于-TDD" class="headerlink" title="关于 TDD"></a>关于 TDD</h2><p>TDD 也是 Rails 社区很流行和推崇的，但是 DHH 其实对此并不太感冒。并不是 TDD 就能写出更好的，更健壮的软件。</p>
<p>事先写测试用例还是事后写并不重要，重要的是自动化测试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;David Heinemeier Hanss
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库相关知识</title>
    <link href="http://chenyukang.github.io/2020/09/08/database.html"/>
    <id>http://chenyukang.github.io/2020/09/08/database.html</id>
    <published>2020-09-08T14:30:29.000Z</published>
    <updated>2020-09-08T14:30:29.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-语言查询语法"><a href="#SQL-语言查询语法" class="headerlink" title="SQL 语言查询语法"></a>SQL 语言查询语法</h2><p><a href="https://www.kancloud.cn/lianglhm36/sql/173500" target="_blank" rel="external">https://www.kancloud.cn/lianglhm36/sql/173500</a></p>
<h3 id="内外链接"><a href="#内外链接" class="headerlink" title="内外链接"></a>内外链接</h3><ul>
<li><p>内连接<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> a.*,b.* <span class="keyword">from</span> a <span class="keyword">inner</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id=b.parent_id</div></pre></td></tr></table></figure></p>
</li>
<li><p>左连接<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> a.*,b.* <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id=b.parent_id</div></pre></td></tr></table></figure></p>
</li>
<li><p>右连接<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> a.*,b.* <span class="keyword">from</span> a <span class="keyword">right</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id=b.parent_id</div></pre></td></tr></table></figure></p>
</li>
<li><p>全连接<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> a.*,b.* <span class="keyword">from</span> a <span class="keyword">full</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id=b.parent_id</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>考虑 CUSTOMERS 表，表中记录如下所示：</p>
<p><img src="/images/database.org_20190730_224332.png" width="70%" hegiht="70%" align="center"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> CUSTOMERS <span class="keyword">WHERE</span> <span class="keyword">ID</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">ID</span> <span class="keyword">FROM</span> CUSTOMERS <span class="keyword">WHERE</span> SALARY &gt; <span class="number">4500</span>)</div></pre></td></tr></table></figure>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> SUBJECT, <span class="keyword">YEAR</span>, <span class="keyword">Count</span>(*) <span class="keyword">FROM</span> Student <span class="keyword">GROUP</span> <span class="keyword">BY</span> SUBJECT, <span class="keyword">YEAR</span>;</div></pre></td></tr></table></figure>
<h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h3><p>SQL 提供了五个固有聚集函数，平均值：avg 最小值：min 最大值：max 总和：sum 计数：count</p>
<p>任何没有出现在 group by 子句中的属性如果出现在 select 子句中的话，它只能出现在聚集函数的内部。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"># 找出每个系的教师平均工资</div><div class="line"><span class="keyword">SELECT</span> dept_name, <span class="keyword">avg</span>(salary) <span class="keyword">AS</span> avg_salary <span class="keyword">FROM</span> instructor <span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_name</div></pre></td></tr></table></figure>
<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">select</span> ename,deptno,sal <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=(<span class="keyword">select</span> deptno <span class="keyword">from</span> dept <span class="keyword">where</span> loc=<span class="string">'NEW YORK'</span>)；</div></pre></td></tr></table></figure>
<h2 id="MySQL-索引方法？索引的优化？"><a href="#MySQL-索引方法？索引的优化？" class="headerlink" title="MySQL 索引方法？索引的优化？"></a>MySQL 索引方法？索引的优化？</h2><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="external">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>
<h3 id="为什么索引使用-B-树"><a href="#为什么索引使用-B-树" class="headerlink" title="为什么索引使用 B+ 树"></a>为什么索引使用 B+ 树</h3><p>牵涉到 IO 读取速度相对于内存读取慢很多的原因，IO 读取按照块读取，通常一次性读取 4K，局部性原理等。</p>
<h3 id="索引优化的原则"><a href="#索引优化的原则" class="headerlink" title="索引优化的原则:"></a>索引优化的原则:</h3><ul>
<li>最左前缀匹配原则，非常重要的原则，mysql 会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如 a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立 (a,b,c,d) 顺序的索引，d是用不到索引的，如果建立 (a,b,d,c) 的索引则都可以用到，a,b,d 的顺序可以任意调整。</li>
<li>和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。</li>
<li>尽量选择区分度高的列作为索引，区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。</li>
<li>索引列不能参与计算，保持列“干净”，比如 from_unixtime(create_time) =’2014-05-29’， 更高效的写法为: create_time = unix_timestamp(’2014-05-29’)。</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。</li>
</ul>
<h3 id="会使用-explain-命令调试-sql-语句"><a href="#会使用-explain-命令调试-sql-语句" class="headerlink" title="会使用 explain 命令调试 sql 语句"></a>会使用 explain 命令调试 sql 语句</h3><h2 id="InnoDB-与-MyISAM-区别？"><a href="#InnoDB-与-MyISAM-区别？" class="headerlink" title="InnoDB 与 MyISAM 区别？"></a>InnoDB 与 MyISAM 区别？</h2><p>MyISAM 存储引擎的特点是：表级锁、不支持事务和全文索引，适合一些 CMS 内容管理系统作为后台数据库使用，但是使用大并发、重负荷生产系统上，表锁结构的特性就显得力不从心。</p>
<p>InnoDB 存储引擎的特点是：行级锁、事务安全（ACID 兼容）、支持外键、不支持 FULLTEXT 类型的索引(5.6.4 以后版本开始支持 FULLTEXT 类型的索引)。InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎。InnoDB 是为处理巨大量时拥有最大性能而设计的。它的 CPU 效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。</p>
<p>注意： InnoDB 表的行锁也不是绝对的，假如在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表，例如 update table set num=1 where name like “a%”。</p>
<p>两种类型最主要的差别就是 InnoDB 支持事务处理与外键和行级锁。而 MyISAM 不支持。所以 MyISAM往往就容易被人认为只适合在小项目中使用。</p>
<h2 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h2><p>什么是数据库的事务？事务其实就是单个数据逻辑单元组成的对象操作集合，而数据库的终极目标就是使数据库从一个一致的状态转换到另一个一致的状态，ACID 中的一致性（Consistency），而原子性（Atomicity）、隔离性（Isolation）、持久性（Durability）是为了实现这个目标的手段。</p>
<h2 id="事务的四个隔离级别"><a href="#事务的四个隔离级别" class="headerlink" title="事务的四个隔离级别"></a>事务的四个隔离级别</h2><p><a href="https://www.cnblogs.com/zhoujinyi/p/3437475.html" target="_blank" rel="external">https://www.cnblogs.com/zhoujinyi/p/3437475.html</a> <a href="https://www.jianshu.com/p/4e3edbedb9a8" target="_blank" rel="external">https://www.jianshu.com/p/4e3edbedb9a8</a></p>
<ul>
<li>读未提交，其隔离级别最低，允许脏读。换句话说就是，如果一个事务正在处理某一数据，并对其进行了更新，但是同时没有提交事务，允许另一个事务也可以访问</li>
<li>读已提交，和读未提交的区别就是。读未提交可以读取到别人没有提交的数据，但是读已提交只能读取到别人提交后的值，事务进行的中间值不会读取到</li>
<li>可重复读，简单来说就是事务处理过程中多次读取同一个数据的时候，这个值不会发生改变，其值都和第一次查询到的数据是一致的</li>
<li>串行化，是最严格的隔离级别，他要求所有的事务都被串行执行，既事务只能一个接一个的进行处理，不能并发执</li>
</ul>
<p>InnoDB 默认是可重复读的。</p>
<p><img src="/images/database.org_20190730_005734.png" alt="file:img/database.org_20190730_005734.png"></p>
<h2 id="查询优化-从索引上优化，从-SQL-语言上优化"><a href="#查询优化-从索引上优化，从-SQL-语言上优化" class="headerlink" title="查询优化(从索引上优化，从 SQL 语言上优化)"></a>查询优化(从索引上优化，从 SQL 语言上优化)</h2><h2 id="B-与-B-树区别？"><a href="#B-与-B-树区别？" class="headerlink" title="B- 与 B+树区别？"></a>B- 与 B+树区别？</h2><p>由于 B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是 B 树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 B+树更加适合在区间查询的情况，所以通常 B+树用于数据库索引，而 B 树则常用于文件索引。</p>
<ul>
<li>B+树的磁盘读写代价更低</li>
<li>B+树的查询效率更加稳定</li>
</ul>
<h2 id="MySQL-的联合索引-又称多列索引-是什么？生效的条件？"><a href="#MySQL-的联合索引-又称多列索引-是什么？生效的条件？" class="headerlink" title="MySQL 的联合索引(又称多列索引)是什么？生效的条件？"></a>MySQL 的联合索引(又称多列索引)是什么？生效的条件？</h2><p><a href="https://cloud.tencent.com/developer/article/1030117" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1030117</a></p>
<p>复合索引（多列 b+tree，使用多列值组合而成的 b+tree 索引）。</p>
<p>组合索引的生效原则是 从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；所以说创建复合索引时，应该仔细考虑列的顺序。</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p><a href="https://database.51cto.com/art/201809/583857.htm" target="_blank" rel="external">https://database.51cto.com/art/201809/583857.htm</a></p>
<p>单个表 1000w 的数据量下读写速度都比较好。</p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul>
<li>悲观锁</li>
</ul>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。</p>
<ul>
<li>乐观锁</li>
</ul>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
<ul>
<li>两种锁的使用场景</li>
</ul>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<p>作者：SnailClimb链接：<a href="https://juejin.im/post/5b4977ae5188251b146b2fc8" target="_blank" rel="external">https://juejin.im/post/5b4977ae5188251b146b2fc8</a></p>
<h2 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SQL-语言查询语法&quot;&gt;&lt;a href=&quot;#SQL-语言查询语法&quot; class=&quot;headerlink&quot; title=&quot;SQL 语言查询语法&quot;&gt;&lt;/a&gt;SQL 语言查询语法&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/liang
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>限流相关知识</title>
    <link href="http://chenyukang.github.io/2020/09/08/req-limit.html"/>
    <id>http://chenyukang.github.io/2020/09/08/req-limit.html</id>
    <published>2020-09-08T13:41:00.000Z</published>
    <updated>2020-09-08T13:41:00.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本限流原理"><a href="#基本限流原理" class="headerlink" title="基本限流原理"></a>基本限流原理</h2><blockquote>
<p>业界较为常见的两个基础限流算法是漏斗算法和令牌算法，这两个算法大同小异。漏斗算法可以理解为每一个请求都会消耗一定的空气，而漏斗里的空气是有限的，通过漏水的方式获得空气的速率也是有限的。令牌算法可以理解为每一个请求都会消耗一个令牌，而令牌桶生产令牌的能力是有限的，存放令牌的桶容量也是有限的。</p>
</blockquote>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。</p>
<p><img src="/images/arc.org_20190731_145606.png" alt="file:img/arc.org_20190731_145606.png"></p>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><ul>
<li><p>定义一个令牌桶，其拥有几个关键属性</p>
<ul>
<li>桶容量</li>
<li>令牌产生速率</li>
<li>当前桶中令牌数</li>
<li>最近一次取（生成）令牌时间</li>
</ul>
</li>
<li><p>从桶中申请令牌，这一步中有两个关键动作</p>
<ul>
<li>根据上一次生成令牌时间到现在的时间，及生成速率计算出当前令牌桶中的令牌数</li>
<li>判断令牌桶中是否有足够的令牌，并返回结果</li>
</ul>
</li>
</ul>
<p><img src="/images/arc.org_20190731_145621.png" alt="file:img/arc.org_20190731_145621.png"></p>
<h3 id="两者差异"><a href="#两者差异" class="headerlink" title="两者差异"></a>两者差异</h3><p>本质上是生产者消费者的事情。而实际上，这两种算法具有截然不同的特性并且为截然不同的目的而使用。它们之间最主要的差别在于：</p>
<p>漏桶算法能够强行限制数据的传输速率，而令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。</p>
<p>漏桶: 漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。</p>
<p>令牌桶: 生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。</p>
<h2 id="一些实现"><a href="#一些实现" class="headerlink" title="一些实现"></a>一些实现</h2><h3 id="Nginx-的限流"><a href="#Nginx-的限流" class="headerlink" title="Nginx 的限流"></a>Nginx 的限流</h3><p><a href="https://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="external">参考 Nginx 文档</a>，Nginx 使用的就是漏桶算法，使用方法如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=perip:<span class="number">10m</span> rate=1r/s;</div><div class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$server_name</span> zone=perserver:<span class="number">10m</span> rate=10r/s;</div><div class="line"></div><div class="line"></div><div class="line"><span class="section">server</span> &#123;</div><div class="line">    ...</div><div class="line">    <span class="attribute">limit_req</span> zone=perip burst=<span class="number">5</span> nodelay;</div><div class="line">    <span class="attribute">limit_req</span> zone=perserver burst=<span class="number">10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-shared-cache-简单实现"><a href="#使用-shared-cache-简单实现" class="headerlink" title="使用 shared.cache 简单实现"></a>使用 shared.cache 简单实现</h3><p>如果我们是简单限制请求到后端的 RPS， 但是又有一些情况需要特殊处理，比如某些 token 就不限制等，那么可以利用 OpenResty 的 shared.cache  的 key 过期时间这个特性。<a href="https://github.com/Kong/kong/blob/0.10.3/kong/tools/database_cache.lua" target="_blank" rel="external">Kong 的 cache 层做了很好的封装</a>，可以参考，限制 RPS 基本代码如下所示：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">rps_check</span><span class="params">(conf, request_uri, limit)</span></span></div><div class="line">  <span class="keyword">local</span> key = get_local_key(ngx.ctx.api.id, request_uri)</div><div class="line">  <span class="keyword">local</span> current, _ = cache.sh_get(key)</div><div class="line">  <span class="keyword">if</span> current ~= <span class="literal">nil</span> <span class="keyword">and</span> current &gt; limit <span class="keyword">then</span></div><div class="line">     <span class="keyword">return</span> ... <span class="comment">-- rejct request and return</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  cache.sh_add(key, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">--  设置过期时间为 1 s</span></div><div class="line">  <span class="keyword">local</span> _, err = cache.sh_incr(key, <span class="number">1</span>) <span class="comment">--  处理请求，增加 value</span></div><div class="line">  <span class="keyword">if</span> err <span class="keyword">then</span> <span class="keyword">return</span> <span class="literal">nil</span>, err <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>或者使用 OpenResty 的更完善的实现： <a href="https://github.com/openresty/lua-resty-limit-traffic" target="_blank" rel="external">https://github.com/openresty/lua-resty-limit-traffic</a></p>
<h3 id="Redis-cell"><a href="#Redis-cell" class="headerlink" title="Redis-cell"></a>Redis-cell</h3><p>我们可以使用 Redis + Lua 来实现这个限流功能，但是 Lua 的性能要比 C 弱很多，通常这个限流算法能达到 1w 左右的 QPS 就到顶了。还可以使用 Redis-Cell 模块，其内部使用 Rust 实现，它能达到 5w 左右的 QPS 也就到极限了。这时候它们都进入了满负荷状态，但是在生产环境中我们不会希望它们一直满负荷工作。</p>
<p>限流组件，使用 Rust 实现：<a href="https://www.jianshu.com/p/1b026b874c40" target="_blank" rel="external">https://www.jianshu.com/p/1b026b874c40</a></p>
<h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><p><img src="/images/arc.org_20190731_145930.png" alt="file:img/arc.org_20190731_145930.png"></p>
<blockquote>
<p>我们将整体的 QPS 按照权重分散多每个子节点，每个字节点在内存中进行单机限流。如果每个节点都是对等的，那么每个子节点就可以分得 1/n 的 QPS。</p>
<p>它的优点在于分散了限流压力，将 IO 操作变成纯内存计算，这样就可以很轻松地应对超高的 QPS 限流。但是这也增加了系统的复杂度，需要有一个集中的配置中心来向每个子节点来分发 QPS 阈值，需要每个应用字节点向这个配置中心进行注册，需要有一个配置管理后台来对系统的 QPS 分配进行管理。</p>
</blockquote>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://juejin.im/post/5cf2007951882521bf3407dbhttps://segmentfault.com/a/1190000015967922https://www.jianshu.com/p/1b026b874c40[令牌桶算法](https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95" target="_blank" rel="external">https://juejin.im/post/5cf2007951882521bf3407dbhttps://segmentfault.com/a/1190000015967922https://www.jianshu.com/p/1b026b874c40[令牌桶算法](https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本限流原理&quot;&gt;&lt;a href=&quot;#基本限流原理&quot; class=&quot;headerlink&quot; title=&quot;基本限流原理&quot;&gt;&lt;/a&gt;基本限流原理&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;业界较为常见的两个基础限流算法是漏斗算法和令牌算法，这两个算法大同小异。漏斗算法可
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络相关知识</title>
    <link href="http://chenyukang.github.io/2020/09/08/networking-notes.html"/>
    <id>http://chenyukang.github.io/2020/09/08/networking-notes.html</id>
    <published>2020-09-08T12:59:08.000Z</published>
    <updated>2020-09-08T12:59:08.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h1><p>分为递归解析和迭代解析</p>
<p><a href="https://blog.csdn.net/lycb_gz/article/details/11720247" target="_blank" rel="external">https://blog.csdn.net/lycb_gz/article/details/11720247</a></p>
<h1 id="APR-欺骗"><a href="#APR-欺骗" class="headerlink" title="APR 欺骗"></a>APR 欺骗</h1><p>ARP 欺骗是一种在局域网中常用的攻击手段，目的是让局域网中指定的（或全部）的目标机器的数据包都通过攻击者主机进行转发，是实现中间人攻击的常用手段，从而实现数据监听、篡改、重放、钓鱼等攻击方式。</p>
<h1 id="TCP-IP-报文长度和格式"><a href="#TCP-IP-报文长度和格式" class="headerlink" title="TCP/IP 报文长度和格式"></a>TCP/IP 报文长度和格式</h1><p>IP 头部信息：头部长度：通常 20 字节，有选项时更长，总共不超过 60 字节。IP 数据报长度：65535 字节。</p>
<p><img src="/images/networking.org_20190731_120051.png" width="70%" hegiht="70%" align="center"></p>
<p>TCP 协议，在传输层。特点：可靠性。通过连接管理（三握四挥），序列号，确认号，拥塞控制，重传控制来保证可靠性。头部长度：一般为 20 字节，选项最多 40 字节，限制 60 字节。</p>
<p><img src="/images/networking.org_20190731_120147.png" width="60%" hegiht="60%" align="center"></p>
<h1 id="TCP-最大报文长度-MSS"><a href="#TCP-最大报文长度-MSS" class="headerlink" title="TCP 最大报文长度 (MSS)"></a>TCP 最大报文长度 (MSS)</h1><p><a href="https://blog.csdn.net/codejoker/article/details/5437141" target="_blank" rel="external">https://blog.csdn.net/codejoker/article/details/5437141</a></p>
<p>TCP 提供的是一种面向连接的，可靠的字节流服务，TCP 提供可靠性的一种重要的方式就是 MSS。通过MSS，应用数据被分割成 TCP 认为最适合发送的数 据块，由 TCP 传递给 IP 的信息单位称为报文段或段(segment)。代表一个 TCP socket 的结构体 struct tcp_sock 中有多个成员用于确定应用数据被分割成最大为多大的数据块较为合适(最大报文段长度 MSS)。我们不难联想到，跟最大报文段长度最为相关的一个参数是网络设备接口的 MTU，以太网的 MTU 是 1500，基本 IP 首部长度为 20，TCP 首部是20，所 以 MSS 的值可达 1460(MSS 不包括协议首部，只包含应用数据)。</p>
<p>本地以太网中 MSS 为 1460 的说法并不正确，它还会动态变化，如果 IP 首部和 TCP 首部中出现选项，则 MSS 要相应的减小，一般 TCP 首部中会 有 12 字节的时间戳选项(外加两字节的填充选项)，这时的 MSS 就等于 1448。MSS 的主要作用是限制另一端主机发送的数据的长度，同时，主机本身也控制自己发送数据报的长度，这将使以较小 MTU 连接到一个网络上的主机避免分段。</p>
<h1 id="如果使用-TCP-希望传输一个复杂的对象应该怎么传输？"><a href="#如果使用-TCP-希望传输一个复杂的对象应该怎么传输？" class="headerlink" title="如果使用 TCP 希望传输一个复杂的对象应该怎么传输？"></a>如果使用 TCP 希望传输一个复杂的对象应该怎么传输？</h1><p>TCP 中的流是指流入进程或者从进程中流出的字节序列。所以向 Java/golang 等高级语言在进行 TCP通信是都需要将相应的实体序列化才能进行传输。</p>
<h1 id="TCP-IP-中如何解决粘包问题？如果一直传输数据怎么拆包"><a href="#TCP-IP-中如何解决粘包问题？如果一直传输数据怎么拆包" class="headerlink" title="TCP/IP 中如何解决粘包问题？如果一直传输数据怎么拆包?"></a>TCP/IP 中如何解决粘包问题？如果一直传输数据怎么拆包?</h1><p>应用层协议，不管是标准的还是自己定义的。“粘包”问题是伪问题。</p>
<p><a href="http://www.hchstudio.cn/article/2018/d5b3/" target="_blank" rel="external">http://www.hchstudio.cn/article/2018/d5b3/</a></p>
<p><a href="https://img.hchstudio.cn/TCP.gif" target="_blank" rel="external">https://img.hchstudio.cn/TCP.gif</a></p>
<h1 id="TCP-连接和断开的状态图"><a href="#TCP-连接和断开的状态图" class="headerlink" title="TCP 连接和断开的状态图"></a>TCP 连接和断开的状态图</h1><p>connect:</p>
<p><img src="/images/networking.org_20190802_115508.png" width="60%" hegiht="60%" align="center"></p>
<p>disconnect:</p>
<p><img src="/images/networking.org_20190802_115604.png" width="60%" hegiht="60%" align="center"></p>
<p>为什么 TCP 连接断开的时候要<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="external">进行四次握手</a>：</p>
<h1 id="TCP-四次挥手的-TIME-WAIT"><a href="#TCP-四次挥手的-TIME-WAIT" class="headerlink" title="TCP 四次挥手的 TIME_WAIT"></a>TCP 四次挥手的 TIME_WAIT</h1><p>时间段长为 2MSL（报文段最大生存时间）</p>
<ul>
<li>TIME_WAIT 存在的理由之一是尽可能护送最后的 ACK 达到对端，保证可靠地终止 TCP 链接。</li>
<li>假设 tcp 连接是： A(1.2.3.4:8888)——B(6.7.8.9:9999), 这就是一个 tcp 四元组。当 tcp 连接关闭后， 四元组释放。TIME_WAIT 存在的理由之二是新旧四元组互不干扰。</li>
</ul>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC（Remote Procedure Call）—远程过程调用 ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发分布式程序就像开发本地程序一样简单。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DNS-域名解析&quot;&gt;&lt;a href=&quot;#DNS-域名解析&quot; class=&quot;headerlink&quot; title=&quot;DNS 域名解析&quot;&gt;&lt;/a&gt;DNS 域名解析&lt;/h1&gt;&lt;p&gt;分为递归解析和迭代解析&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员如何提高英文写作</title>
    <link href="http://chenyukang.github.io/2019/11/07/improve-english-writing-as-progammer.html"/>
    <id>http://chenyukang.github.io/2019/11/07/improve-english-writing-as-progammer.html</id>
    <published>2019-11-07T00:45:53.000Z</published>
    <updated>2019-11-07T12:45:59.838Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个月坚持了一段时间英文写作，兴趣和自信心都大为增强。为什么突然想锻炼自己的英文写作能力呢，是因为工作中要写个什么英文的白皮书，然后发现懂技术的不太会写，会写英文的不太懂技术。最后找了团队中的一个留学生帮忙，大家跌跌撞撞把工作完成了。仔细想想这就是稀缺能力啊，按照刻意练习的套路，我应该好好提高一下自己的英文写作能力。</p>
<p><img src="/images/image-20191107195802111.png" alt="image-20191107195802111"></p>
<p>然后，我就开始在一些社区，比如 dev.to 写技术文章，在 Quora 上回答问题等，这些坚持了两个月左右，自我感觉收获不少。至少，现在让我写一篇英文类的长文，我是好无压力并且有些享受的(可能还处于自我感觉良好的时期的缘故)。</p>
<p>下面总结一下关于英文写作的一些自我心得。 </p>
<h2 id="抛去恐惧心理"><a href="#抛去恐惧心理" class="headerlink" title="抛去恐惧心理"></a>抛去恐惧心理</h2><p>这是很多人要克服的第一关，想着中文都写不溜，英文如何写？写作这个东西就是需要不断练习的，即使文笔不行，首先要做到的是写出来，并且简明扼要。文章最重要的目的是表达自己，并且让人易懂，更高的要求才是让人产生读的乐趣。对于绝大部分科技类的写作来说，准确是第一要素。 </p>
<p>如何抛去恐惧心理？唯一的办法就是多读、多写，并且让大家看，收集反馈然后不断改进。 </p>
<h2 id="在哪里写"><a href="#在哪里写" class="headerlink" title="在哪里写"></a>在哪里写</h2><p>像我刚才说的，有很多不错的技术社区，比如 Github、StackOverflow、Quora, 这些都是英文表达的场所，也是一个很好的锻炼自己英文写作的平台。从小处开始，可以写一个英文的 README，代码中使用良好的英文注释？在 Quora 上回答问题是更好的方式，因为这是一个互动的平台，你的回答会被多个人看到，这样可能会有一些反馈。</p>
<p>比如这个找 Quora 里的回答，题主问的是学习编程是否需要很多数据技巧？这对于我们这样的多年程序员来说，自然是有一些心得的，然后我就写了一些自己的想法作为回答。后面有一位朋友写了另外一个回答： </p>
<p>“题主，数学技能是次要的，你应该好好学学英文写作，这样至少不会让你像上面这位回答者这一样犯一些低级的错误。” </p>
<p>没多久我就看到了这条回答，然后看了看自己真的是犯了一些很明显的语法错误，修正后再回复了一下这位朋友，他表示自己也有点刻薄了，哈哈。其实大家对这种“助人助己”的学习方法是很乐于接受的，只要是给社区提供有用的东西。 </p>
<p><img src="/images/pic3.png" alt="pic3"></p>
<p>在 Quora 上还碰到另外一个瑞典的伙计，也帮我提出了一些建议。然后第二天还帮我一句一句做了一个修改版本，发到了我的邮箱。英语不是母语的人写的文章，如果不是让英语为第一语言的朋友阅读，这些表达方面的问题是不容易看出来的。</p>
<p><img src="/images/image-20191107194028413.png" alt="image-20191107194028413"></p>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h3><p>很多人对于自己的词汇量没有信心，觉得词汇量不够不足以表达自己的想法。这是不对的，其实你看看大部分技术类英文文章，对于接受过大学教育的技术人人员来说，应该是 95% 以上的单词都是认识的。对于不认识的单词来说也可以根据上下文来推测的，所以至少词汇不会构成阅读障碍。对于英文写作来说，基于简明表达自己的要求，我们那点四六级词汇也很够玩的。词汇在于平时积累，我现在也在着重注意积累一些词汇。日常使用过程中，多注意一些应文的惯用词汇。有一个 Chrome 插件叫做“单词小卡片”，可以把日常浏览网页的过程中发现的不太熟悉的单词加入列表，可以日后以便回顾。 </p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p><img src="/images/pic1.png" alt="pic1"></p>
<p>阅读和写作是分不开的，只有多读才会发现更多套路。上面提到的那些社区都有很多不错的英文内容可以读，另外要特别提到一个的是 medium.com，类比为国内的简书。不过个人感觉质量比简书的内容好很多，可能是我阅读了付费内容的缘故。这个付费也挺便宜的，一个月 5 美金。 </p>
<p>作为程序员，另外要多阅读就是技术类的书籍。这些年我买了不少英文类的技术书籍，大多是翻过的，而且有少部分是精读完了。其实只要你能坚持阅读完一本 300 页左右的技术书籍，第二本就很简单了。如果是非技术类的英文文章，要数量阅读就需要提高词汇。 </p>
<h3 id="撰写"><a href="#撰写" class="headerlink" title="撰写"></a>撰写</h3><p>其实写作无非是表达自己，中文和英文写作有很多都是相通的。 </p>
<p>撰写过程中需要时刻明白，写的东西是给其他人看的。所以排版也很很重要，如果文章比较长，需要让人看得不至于疲累。适当地配一些贴近情景的图片也非常有助于提高可读性。段落要分明，不要某些段落太长。</p>
<p>最后，即使是英语是母语的人也很容一些常见的语法错误。所以我们需要工具来减少这类问题，grammarly.com 就是非常有用的工具，即使是免费版本对于日常使用来说也是足够了的。 </p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>不断练习，收集反馈，持续改进。唯此而已。 有两本书可以看看。</p>
<ol>
<li><a href="https://book.douban.com/subject/27122346/" target="_blank" rel="external">《七十二堂写作课》</a></li>
<li><a href="https://book.douban.com/subject/1451400/" target="_blank" rel="external">《风格的要素》</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几个月坚持了一段时间英文写作，兴趣和自信心都大为增强。为什么突然想锻炼自己的英文写作能力呢，是因为工作中要写个什么英文的白皮书，然后发现懂技术的不太会写，会写英文的不太懂技术。最后找了团队中的一个留学生帮忙，大家跌跌撞撞把工作完成了。仔细想想这就是稀缺能力啊，按照刻意练
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C 语言的 typecheck</title>
    <link href="http://chenyukang.github.io/2019/08/06/type_check_in_c.html"/>
    <id>http://chenyukang.github.io/2019/08/06/type_check_in_c.html</id>
    <published>2019-08-05T17:31:18.000Z</published>
    <updated>2019-11-07T11:33:37.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类型保证"><a href="#类型保证" class="headerlink" title="类型保证"></a>类型保证</h4><p>强类型的编程语言通常编译器自带一些类型检查，保证代码编译后不会出现类型方面的错误，比如 Rust 之类的甚至做了变量的生命周期检查，以防止内存出错或者未定义行为。常见的变成语言类型如下：</p>
<p><img src="/images/2019_08_06.org_20190806_012652.png" width="70%" hegiht="70%" align="center"></p>
<h4 id="typecheck"><a href="#typecheck" class="headerlink" title="typecheck"></a>typecheck</h4><p> 但是 C 为弱类型语言，弱类型语言，类型检查更不严格，如偏向于容忍隐式类型转换。譬如说 C 语言的 int 可以变成 double。 这样的结果是：容易产生 forbidden behaviours。为了解决类似问题，Linux 内核中的这个宏比较有技巧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> typecheck(type,x)                       \</span></div><div class="line">  (&#123;  type __dummy;                             \</div><div class="line">  typeof(x) __dummy2;                           \</div><div class="line">  (<span class="keyword">void</span>)(&amp;__dummy == &amp;__dummy2);                \</div><div class="line">  <span class="number">1</span>;                                            \</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p> 使用的时候可以保证某些变量为特定的类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> a;</div><div class="line">typecheck(<span class="keyword">char</span>, a);</div></pre></td></tr></table></figure>
<p> 这样就会报出一个编译错误：</p>
<p><img src="/images/2019_08_06.org_20190806_011627.png" width="70%" hegiht="70%" align="center"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;类型保证&quot;&gt;&lt;a href=&quot;#类型保证&quot; class=&quot;headerlink&quot; title=&quot;类型保证&quot;&gt;&lt;/a&gt;类型保证&lt;/h4&gt;&lt;p&gt;强类型的编程语言通常编译器自带一些类型检查，保证代码编译后不会出现类型方面的错误，比如 Rust 之类的甚至做了变量的生命周
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My org-mode stuff</title>
    <link href="http://chenyukang.github.io/2019/08/01/org_mode_stuff.html"/>
    <id>http://chenyukang.github.io/2019/08/01/org_mode_stuff.html</id>
    <published>2019-08-01T11:31:24.000Z</published>
    <updated>2019-08-01T17:15:57.490Z</updated>
    
    <content type="html"><![CDATA[<p> I switched to org-mode from EverNote recently, and the experience imrpoved much for note and journal writing, especially for technical notes. After the whole tool is set appropriately, I am even addicted to writing. During my setting up for org-mode and related tools, I found these code snippets are really handy, so let’s have a share.</p>
<h3 id="Insert-Pic-from-paste"><a href="#Insert-Pic-from-paste" class="headerlink" title="Insert Pic from paste"></a>Insert Pic from paste</h3><p> You need to install <strong>pngpaste</strong> first, then with this elisp function, we can copy the picture from paste very quickly, the picture will store on current directory’s img sub-directory, it will create it if img directory is not exists.</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line">(<span class="name">defun</span> org-insert-image ()</div><div class="line">  (<span class="name">interactive</span>)</div><div class="line">  (<span class="name">let*</span> ((<span class="name">path</span> (<span class="name">concat</span> default-directory <span class="string">"img/"</span>))</div><div class="line">         (<span class="name">image-file</span> (<span class="name">concat</span></div><div class="line">                      path</div><div class="line">                      (<span class="name">buffer-name</span>)</div><div class="line">                      (<span class="name">format-time-string</span> <span class="string">"_%Y%m%d_%H%M%S.png"</span>))))</div><div class="line">    (<span class="name">if</span> (<span class="name">not</span> (<span class="name">file-exists-p</span> path))</div><div class="line">        (<span class="name">mkdir</span> path))</div><div class="line">    (<span class="name">shell-command</span> (<span class="name">concat</span> <span class="string">"pngpaste "</span> image-file))</div><div class="line">    (<span class="name">org-insert-link</span> <span class="literal">nil</span> (<span class="name">concat</span> <span class="string">"file:"</span> image-file) <span class="string">""</span>))</div><div class="line">    <span class="comment">;; (org-display-inline-images) ;; show inline picture</span></div><div class="line">  )</div></pre></td></tr></table></figure>
<h3 id="Using-org-ruby-for-Hexo-publishing"><a href="#Using-org-ruby-for-Hexo-publishing" class="headerlink" title="Using org-ruby for Hexo publishing"></a>Using org-ruby for Hexo publishing</h3><p> I using Hexo for blogging, the default format is markdown in Hexo, so I need to convert org format to markdown format very conveniently, and finally org-ruby solve it. I did some dirty hacks on the codebase, <a href="https://github.com/chenyukang/org-ruby/pull/1/files" target="_blank" rel="external">please have a look at this PR</a>, this PR solve three issues.</p>
<ul>
<li>Add title and path attributes in org file, and the ruby script will extract it for dumping markdown file.</li>
<li>Fix the fill paragraph problem, I don’t need the blanks which will broken the paragraph layout.</li>
<li>Copy the images to proper directory for Hexo, support image size attributes.</li>
</ul>
<p> Then I added an elisp function for auto publish it after saving file whenever “#MD_TITLE:” is founded in buffer:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line">(<span class="name">defun</span> org-publish-to-hexo ()</div><div class="line">  (<span class="name">interactive</span>)</div><div class="line">  (<span class="name">shell-command</span> (<span class="name">concat</span></div><div class="line">                  <span class="string">"org-ruby "</span> <span class="string">"--translate "</span> <span class="string">"markdown "</span> <span class="string">"-a "</span></div><div class="line">                  (<span class="name">buffer-name</span>))))</div><div class="line">(<span class="name">defalias</span> 'op 'org-publish-to-hexo)</div><div class="line"></div><div class="line">(<span class="name">defun</span> buffer-contains-substring (<span class="name">string</span>)</div><div class="line">  (<span class="name">save-excursion</span></div><div class="line">    (<span class="name">save-match-data</span></div><div class="line">      (<span class="name">goto-char</span> (<span class="name">point-min</span>))</div><div class="line">      (<span class="name">search-forward</span> string <span class="literal">nil</span> <span class="literal">t</span>))))</div><div class="line"></div><div class="line">(<span class="name">defun</span> org-auto-publish-save-hook ()</div><div class="line">  (<span class="name">when</span> (<span class="name">and</span> (<span class="name">eq</span> major-mode 'org-mode)</div><div class="line">             (<span class="name">buffer-contains-substring</span> <span class="string">"#+MD_TITLE:"</span>)</div><div class="line">             (<span class="name">buffer-contains-substring</span> <span class="string">"#+MD_PATH:"</span>))</div><div class="line">    (<span class="name">message</span> <span class="string">"publishing to Hexo markdown"</span>)</div><div class="line">    (<span class="name">org-publish-to-hexo</span>)))</div><div class="line"></div><div class="line">(<span class="name">add-hook</span> 'after-save-hook #'org-auto-publish-save-hook)</div><div class="line"></div><div class="line">(<span class="name">defun</span> org-before-save-hook ()</div><div class="line">  (<span class="name">when</span> (<span class="name">eq</span> major-mode 'org-mode)</div><div class="line">    (<span class="name">message</span> <span class="string">"saving org-file"</span>)</div><div class="line">    (<span class="name">pangu-spacing-space-current-buffer</span>)</div><div class="line">    <span class="comment">;;(fill-region (point-min) (point-max))</span></div><div class="line">    ))</div><div class="line">(<span class="name">add-hook</span> 'before-save-hook #'org-before-save-hook)</div></pre></td></tr></table></figure>
<h3 id="pangu-spacing"><a href="#pangu-spacing" class="headerlink" title="pangu-spacing"></a>pangu-spacing</h3><p> This package will add spacing between Chinese word and English word, so I hooked it before save org file:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line">(<span class="name">require</span> 'pangu-spacing)</div><div class="line">(<span class="name">global-pangu-spacing-mode</span> <span class="number">1</span>)</div><div class="line"><span class="comment">;;(setq pangu-spacing-real-insert-separtor t)</span></div><div class="line"></div><div class="line">(<span class="name">defun</span> org-before-save-hook ()</div><div class="line">  (<span class="name">when</span> (<span class="name">eq</span> major-mode 'org-mode)</div><div class="line">    (<span class="name">message</span> <span class="string">"saving org-file"</span>)</div><div class="line">    (<span class="name">pangu-spacing-space-current-buffer</span>)</div><div class="line">    ))</div><div class="line"></div><div class="line">(<span class="name">add-hook</span> 'before-save-hook #'org-before-save-hook)</div></pre></td></tr></table></figure>
<h3 id="org-capture"><a href="#org-capture" class="headerlink" title="org-capture"></a>org-capture</h3><p> And the best thing is org-capture, with this we can write all kinds of tempaltes, for journal writing, I need to generate file according to date and time:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line">(<span class="name">defun</span> create-code-file ()</div><div class="line">  (<span class="name">interactive</span>)</div><div class="line">  (<span class="name">let</span> ((<span class="name">name</span> (<span class="name">concat</span> (<span class="name">format-time-string</span> <span class="string">"%Y_%m_%d_"</span>)</div><div class="line">                       (<span class="name">read-string</span> <span class="string">"file-name: "</span>))))</div><div class="line">    (<span class="name">expand-file-name</span> (<span class="name">format</span> <span class="string">"%s.org"</span> name) <span class="string">"~/Dropbox/org/snippets/"</span>)))</div><div class="line"></div><div class="line">(<span class="name">defun</span> gen-date-file ()</div><div class="line">  <span class="string">"Create an org file in ~/notes/snippets."</span></div><div class="line">  (<span class="name">format-time-string</span> <span class="string">"~/Dropbox/org/journals/%Y_%m_%d.org"</span>))</div><div class="line"></div><div class="line">(<span class="name">setq</span> org-capture-templates</div><div class="line">      '((<span class="string">"t"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/work.org"</span>)</div><div class="line">         <span class="string">"** TODO %?\n  %i\n "</span> :empty-lines <span class="number">1</span>)</div><div class="line">        (<span class="string">"x"</span> <span class="string">"Task"</span> entry (file+datetree <span class="string">"~/Dropbox/org/work.org"</span>)</div><div class="line">         <span class="string">"** TODO %^&#123;priority|[#A]|[#B]|[#C]&#125; %?\n"</span>)</div><div class="line">        (<span class="string">"e"</span> <span class="string">"Task"</span> entry (file+datetree <span class="string">"~/Dropbox/org/life.org"</span>)</div><div class="line">         <span class="string">"** TODO %^&#123;priority|[#A]|[#B]|[#C]&#125; %?\n"</span> :empty-lines <span class="number">1</span>)</div><div class="line">        (<span class="string">"l"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/learn.org"</span>)</div><div class="line">         <span class="string">"** TODO %?\nEntered on %U\n  %i\n\n "</span> :kill-buffer <span class="literal">t</span> :empty-lines <span class="number">1</span>)</div><div class="line">        (<span class="string">"k"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/learn.org"</span>)</div><div class="line">         <span class="string">"* TODO %?\n  %i\n %f\n %a"</span> :empty-lines <span class="number">1</span>)</div><div class="line">        (<span class="string">"j"</span> <span class="string">"Journal"</span> entry (file+datetree <span class="string">"~/Dropbox/org/_journal.org"</span> )</div><div class="line">         <span class="string">"** %?\nEntered on %U\n  %i\n"</span> :empty-lines <span class="number">1</span>)</div><div class="line">        (<span class="string">"J"</span> <span class="string">"Journal"</span> entry (file gen-date-file)</div><div class="line">         <span class="string">"** %?\nEntered on %U\n  %i\n"</span> :empty-lines <span class="number">1</span>)</div><div class="line">        (<span class="string">"c"</span> <span class="string">"Code snippet"</span> entry (file+headline <span class="string">"~/Dropbox/org/_code.org"</span> <span class="string">"Code"</span>)</div><div class="line">         <span class="string">"** %^&#123;desc&#125;\n#+BEGIN_SRC %^&#123;language|ruby|shell|c|rust|emacs-lisp&#125;\n%?\n#+END_SRC"</span> </div><div class="line">          :empty-lines <span class="number">1</span>)</div><div class="line">        (<span class="string">"C"</span> <span class="string">"Notes"</span> entry (file create-code-file)</div><div class="line">         <span class="string">"** %^&#123;desc&#125;\n#+BEGIN_SRC %^&#123;language|ruby|shell|c|rust|emacs-lisp&#125;\n%?\n#+END_SRC"</span> </div><div class="line">          :empty-lines <span class="number">1</span>)</div><div class="line">        ))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; I switched to org-mode from EverNote recently, and the experience imrpoved much for note and journal writing, especially for technical n
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>满足感源自细节</title>
    <link href="http://chenyukang.github.io/2019/07/31/details_matter.html"/>
    <id>http://chenyukang.github.io/2019/07/31/details_matter.html</id>
    <published>2019-07-31T15:40:03.000Z</published>
    <updated>2019-08-02T02:54:01.937Z</updated>
    
    <content type="html"><![CDATA[<p>最近自我感觉生活质量提高了不少，并不是突然撞大运发大财了，总结下来居然都是一些小细节，奇怪正是这些小细节每次都会让我会心一笑。</p>
<p><img src="/images/2019_07_26.org_20190727_085906.png" width="70%" hegiht="70%" align="center"></p>
<h4 id="org-mode"><a href="#org-mode" class="headerlink" title="org-mode"></a>org-mode</h4><p>作为一个近十二年的 Emacs 用户，最近开始使用 org-mode 了。之前一直偶尔看到说什么单独为了org-mode 而花时间熟悉 Emacs 也是值得的，不过我一直没认真看，因为我认为在 Emacs 下不太适合大量编辑中文，快捷键太多在中文输入的过程中会有一些影响。</p>
<p>最近因为杂事比较多，我特别想要一个结合了日程管理和文档管理的软件。之前用过 Bear，这款软件的好处在于其编辑支持得特别好，但是 Bear 没有日程管理。后来又重新用回 EverNote，这东西的文字编辑支持有点弱，日程管理就是个最基本的清单。还有一些代码嵌入方面的问题，拷贝进去支持再拷贝出来居然其中嵌了部分中文符号。</p>
<p>最后我终于花了点时间来看看这个传说中的 org-mode 到底神奇在何处。结果真的符合了好香定律，我怎么不一开始用 Emacs 就着手用这呢，后悔万千！</p>
<p>其实不管日程管理也好，日志、技术笔记等也好，本质上都是文字。org-mode 的日程和笔记都是存储的最原始的文本格式，而 org-mode 的编辑模式类似 Bear，写起来非常容易上手。和 Markdown 类似属于「易读易写」的轻量级标签格式。</p>
<p>日程管理也有一些记录时间、统计时间，培养习惯的打卡类日程计划。配合 org-agenda 的各种视图，org-capture 的可定制的模板，用起来真是简洁而又迅速。自己再定制一些函数和脚本，实现从剪切板拷贝图片，使用修改过的 <a href="https://github.com/chenyukang/org-ruby/tree/block-version" target="_blank" rel="external">org-ruby</a> 自动从 org 转换为 Markdown，反正只要是文本其可塑性就非常强。</p>
<p><img src="/images/2019_07_26.org_20190727_003933.png" width="70%" hegiht="70%" align="center"></p>
<p>这才是对程序员最友好、最强大的文档和日程管理工具，<strong>其满足点在于『可定制』</strong>。</p>
<h4 id="全屏中小红点"><a href="#全屏中小红点" class="headerlink" title="全屏中小红点"></a>全屏中小红点</h4><p>当我开始大量使用 org-mode 记录之后，就不可避免地需要在全屏的 Emacs 下输入中文。而这经常会被打乱，总结一下发现其实是因为全屏状态下我经常会不知道目前是否启用了中文输入法。全屏模式下看不到输入法的任何图标，Baidu 的 Mac 输入法这个浮动状态栏不会在 Emacs 全屏的模式下显示，而且那个辐条本身看起来也太占空间了。在没有图标的情况下只有靠 Shift 或者 Ctrl blank 瞎切换了，非常让人厌烦。</p>
<p>这个困扰很久的问题最近也终于解决了， 这个 <a href="https://github.com/tekezo/ShowyEdge" target="_blank" rel="external">ShowEdge</a> 工具可以根据不同的输入法，配置不同的颜色，而且在任何全屏状态都根据输入法显示颜色。我的屏幕顶部就配置了这么一个小红点：</p>
<p><img src="/images/CAPTURE-2019_07_26.org_20190727_000238.png" alt="file:img/CAPTURE-2019_07_26.org_20190727_000238.png"></p>
<p>从此输入中文的体验大幅提高！虽然这是非常细节的一个地方，但是当你想到折磨自己的问题，其他人也关注到了，并且用了极其符合自己使用习惯的开源软件解决了，顿时觉得世界真美好！</p>
<p><strong>这里的满足点在于『可控性』</strong>。</p>
<h4 id="黑暗中的黄色光"><a href="#黑暗中的黄色光" class="headerlink" title="黑暗中的黄色光"></a>黑暗中的黄色光</h4><p>这东西犹如黑暗中的萤火虫，让人温暖，哈哈，其实就是小米的一款感应夜灯。我对小米的这种小的智能家电比较感兴趣，比如小爱同学也不错。这款夜灯的好处在于自动感应，进洗手间自己就亮，我每次都是比较晚才去洗漱刷牙，这灯不太亮也不太暗，而且可以根据声音、移动、和自然光亮度自动开关。其实功能很简单，符合软件设计中的哲学：专注唯一功能，但是功能做到极致。</p>
<p><img src="/images/2019_07_26.org_20190727_004316.png" width="350" hegiht="400" align="center"></p>
<p><strong>这应该是简单地满足了『确定性』的心理需求</strong>，为什么像语音助手这类东西虽然看起来比较炫酷，但用的人并不多，因为语音识别在日常使用过程中还是会存在各种干扰，最终造成使用过程中存在一些不确定性，从而影响了根本的使用体验。</p>
<p>Entered on [2019-07-26 五 23:31]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近自我感觉生活质量提高了不少，并不是突然撞大运发大财了，总结下来居然都是一些小细节，奇怪正是这些小细节每次都会让我会心一笑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_07_26.org_20190727_085906.png&quot; width=&quot;70%&quot; 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>保存 kmacro </title>
    <link href="http://chenyukang.github.io/2019/06/23/2019-06-23-random-notes.html"/>
    <id>http://chenyukang.github.io/2019/06/23/2019-06-23-random-notes.html</id>
    <published>2019-06-23T15:48:42.000Z</published>
    <updated>2019-06-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>宏是很强大的编辑方法，如果要长久保存一些宏可以使用下面的办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">M-x start-kbd-macro</div></pre></td></tr></table></figure>
<p>开始记录宏，通常快捷键为”C-x (“, 结束的快捷键为 “C-x )”。</p>
<p> 然后使用命令: </p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">M-x kmacro-name-last-macro</div></pre></td></tr></table></figure>
<p>  可以把这条宏给命名，如果要保存这个宏以便日后使用，需要打开 init.el 继续使用命令： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">M-x insert-kbd-macro</div></pre></td></tr></table></figure>
<p>选中命名的宏，这样就在 init.el 里面插入了刚才的宏，这个名字也就可以当作日常命令使用了。</p>
<p>例如我新建一个宏，作用是查找测试文件中的 “#[ignore]”，并删除掉那行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(fset &apos;rust-ignore</div><div class="line">      (lambda (&amp;optional arg) &quot;Keyboard macro.&quot; (interactive &quot;p&quot;)</div><div class="line">        (kmacro-exec-ring-item</div><div class="line">         (quote ([12 115 101 97 114 99 104 return 35 91 105 103 110 111 114 101 return 1 11 11 14] 0 &quot;%d&quot;)) arg)))</div></pre></td></tr></table></figure>
<p>如果要重复执行，则需要运行： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">C-x z</div></pre></td></tr></table></figure>
<p>当然后面可以连续按 z z z …. ， 执行多遍。</p>
<p> 参考: <a href="https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function" target="_blank" rel="external">https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;宏是很强大的编辑方法，如果要长久保存一些宏可以使用下面的办法：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;M-x start-kbd-macr
    
    </summary>
    
    
      <category term="Notes" scheme="http://chenyukang.github.io/tags/Notes/"/>
    
      <category term="Emacs" scheme="http://chenyukang.github.io/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>2019，愿你也健康</title>
    <link href="http://chenyukang.github.io/2019/01/23/2019-wishes.html"/>
    <id>http://chenyukang.github.io/2019/01/23/2019-wishes.html</id>
    <published>2019-01-23T15:48:42.000Z</published>
    <updated>2019-01-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h4><p>最近在坚持养成每天尽量花一小时锻炼的习惯，因为我想在 2019 年有个更健康、有活力的身体。</p>
<p>随着年纪的增长，身体的一些反馈还是如实地告诉自己在变老。衰老就是能力不断地退化、消失。之前打球能蹦蹦跳跳的，现在多跑跑就会喘气；之前精力更好、更喜欢到处走动，现在更倾向于静静休息。去年有的时候身体感觉不太好，有段时间特别疲劳，甚至也体验过一段低迷的至暗时刻。大概是因为生活不规律，而且基本没有怎么锻炼，体重也不断上升。因为在 2017 年初打篮球的时候把膝盖伤了，后来也不能激烈打球了。现在比较适合自己的运动方式就是跑步、游泳、散步之类的。</p>
<hr>
<h4 id="人总是会忘掉这件事"><a href="#人总是会忘掉这件事" class="headerlink" title="人总是会忘掉这件事"></a>人总是会忘掉这件事</h4><p>当然锻炼养生也不能抵抗衰老，这是个自然过程，锻炼至少能有助于健康。健康是所有幸福的最大基础，比什么都重要，俗话说『宁做健康的乞丐，也比做病恹恹的国王快活得多』。人更无法逃避的是死亡，这是所有生物的最终归宿和命运。只是人总会渐渐忘记自己会死，梁文道说的一个故事：</p>
<blockquote>
<p>很多年前，一位德国摄影师跟一个记者合作的拍摄计划，很有意思。那个摄影师去很多的临终病房，拍摄一些快要死去的人，趁他们还在世的时候，拍下他们的遗照。然后他们刚刚离开，合上眼睛的时候，又为他们再拍一张照片，两张照片放在同一版上，前面则是文字记者做的采访。</p>
<p>在这一系列的采访跟摄影当中，其中一个已死的老太太，在她的采访里面说的一句话，他一辈子都不会忘记。她说什么呢？她跟文字记者说，“你看，你看”，就指着病房玻璃外面楼下对面马路的一个超级市场，她指着那个超级市场跟摄影师和记者说：“<strong>你看那里头的人们，天天进进出出买东西，买面包、买肉、买卫生纸，你看他们的样子，他们好像从来不觉得自己会死。</strong>”</p>
</blockquote>
<h4 id="读《最后的告别》"><a href="#读《最后的告别》" class="headerlink" title="读《最后的告别》"></a>读《最后的告别》</h4><p>这本书很多人都推荐过，我最近刚好也看了一遍。这里面谈了一些人在最终衰老、告别时必须面对的问题和思考，其中也有一些作者所经历的老人故事，还有自己的父亲最后的抗争。其中有一个故事印象深刻，看完后我又查了查还真有这么个人和事。</p>
<blockquote>
<p>1980年3月，当附近火山已经开始冒水汽、隆隆作响时，这位83岁的老人却仍然拒绝撤离他在华盛顿奥林匹亚市附近圣海伦山脚的家。他是第一次世界大战时期的飞行员、禁酒时期的私酒制造者，已经在灵湖的这所房子里住了半个多世纪了。5年前，他成了鳏夫。所以，当时，在山脚这处300多亩的地盘上，只住着他和他的16只猫。三年前，他在屋顶铲雪的时候掉下来，摔断了腿。医生说他是个“该死的傻瓜”，在这样的年龄还爬到房顶去做事。<br>　　<br>　　“该死！”他给医生骂回去，“<strong>我都 80岁了！我有权做决定，有权做我想做的事。</strong>”</p>
<p>由于受到火山喷发的威胁，官方要求附近居民全部撤离，但是杜鲁门哪儿都不去。火山闷烧了两个多月，官方把撤离区域扩大到火山周围16千米。杜鲁门固执地不肯离开。</p>
<p>　“如果这个地方要毁灭，那我想跟它同归于尽，”他说，“反正如果失去它，我也会在一周之内结果我自己。”他直率、不和悦的讲话方式吸引了记者。他说起话来滔滔不绝，头戴一顶绿色的约翰·迪尔棒球帽，手拿一大高脚杯波旁威士忌和可乐。当地警察考虑为了他好而逮捕他，但是，由于他的年龄以及他们必须得承受的负面新闻，只好作罢。他们提出但凡有机会就带他离开，但他坚决予以拒绝。他告诉一位朋友：“<strong>如果我明天死去，我也已经度过了愉快的一生。我能做的事都做了，想做的事都做了。</strong>”<br>　　<br>　　1980年5月18日早上8点40分，火山终于爆发了，其威力相当于一颗原子弹。巨量的岩浆流吞没了整个湖，埋葬了杜鲁门、他的猫和他的家。事后，他成了偶像——一个老头留在自己家里碰运气，在这种可能性似乎已经消失的年代，他按照自己的方式生活。</p>
<p><img src="/images/1920px-St_Helens_before_1980_eruption_horizon_fixed.jpg" alt="1920px-St_Helens_before_1980_eruption_horizon_fixed"></p>
</blockquote>
<p>相对书中的很多老人来说，这位老人的选择充满了勇气，他以决绝的选择来面对衰老和死亡，并没有经受医院的无尽折磨。年轻人看起来这算是是自杀吧，加缪认为自杀是唯一严肃的哲学问题，看来老人对此已经有了答案。能有多少人老了能还以自己喜欢的生活方式活着，并在最终告别的时候心里都是满足：我已经愉快地度过了一生。</p>
<p>孔子说『未知生<em>，</em>焉知死』，反过来如果没有认真思考过死这件事，人又能真的知道怎么活。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>最近大环境不太好，很多人都在纠结于今年能拿到多少年终，好多事情并不是个人所能决定，自己能最能把握的是自己的身体，珍惜生命、保护好自己，以免年纪轻轻落得一身病，年纪大了用钱换命。</p>
<p>最后推荐一个纪录片：《人世间》。每天都有无数的人在和疾病、死亡抗争，活着对很多人来说其实真不是件容易的事。</p>
<p>日子中很多艰辛和苦难，和生死比起来那就不是事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;坚持&quot;&gt;&lt;a href=&quot;#坚持&quot; class=&quot;headerlink&quot; title=&quot;坚持&quot;&gt;&lt;/a&gt;坚持&lt;/h4&gt;&lt;p&gt;最近在坚持养成每天尽量花一小时锻炼的习惯，因为我想在 2019 年有个更健康、有活力的身体。&lt;/p&gt;
&lt;p&gt;随着年纪的增长，身体的一些反馈还
    
    </summary>
    
    
      <category term="Notes" scheme="http://chenyukang.github.io/tags/Notes/"/>
    
  </entry>
  
</feed>
